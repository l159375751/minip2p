<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>POC1 - P2P Gutenberg</title>
    <script src="https://unpkg.com/nostr-tools@2.1.4/lib/nostr.bundle.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body {
            font-family: monospace;
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background: #fafafa;
        }

        .box {
            background: white;
            border: 2px solid #333;
            padding: 20px;
            margin-bottom: 20px;
        }

        .box h2 {
            margin-top: 0;
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }

        input, button, select {
            font-family: monospace;
            padding: 8px;
            margin: 5px;
        }

        input[type="text"] {
            width: 300px;
        }

        .status {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
        }

        .log {
            background: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 3px 0;
            border-left: 3px solid #999;
            padding-left: 8px;
            margin: 3px 0;
        }

        .log-entry.query { border-color: #00f; }
        .log-entry.answer { border-color: #0f0; }
        .log-entry.transfer { border-color: #f90; }

        .book-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .book-card {
            border: 1px solid #ccc;
            padding: 12px;
            background: #fafafa;
        }

        .book-card h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .book-card button {
            font-size: 11px;
            padding: 4px 8px;
            margin: 2px;
        }

        .search-result {
            background: #f0f9ff;
            border: 1px solid #0891b2;
            padding: 10px;
            margin: 8px 0;
        }

        .search-result h4 {
            margin: 0 0 5px 0;
        }

        .search-result .peer {
            font-size: 11px;
            color: #666;
        }

        .search-result button {
            font-size: 12px;
            padding: 5px 10px;
            margin-top: 5px;
            background: #B5F5B5;
            border: 1px solid #5DA85D;
            cursor: pointer;
        }

        .search-result button:hover {
            background: #A0E8A0;
        }

        .search-result button.completed {
            background: #006400;
            color: white;
            cursor: default;
        }

        .search-result button.neutral {
            background: #f0f0f0;
            border: 1px solid #999;
        }

        .search-result button.neutral:hover {
            background: #e0e0e0;
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
        }

        .icon-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
            border-radius: 6px;
        }

        .icon-button span {
            font-size: 1rem;
            line-height: 1;
        }

        .fingerprint-dot {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #999;
            background: #ddd;
        }
    </style>
</head>
<body>
    <h1>POC1 - P2P Gutenberg Library</h1>

    <div class="status">
        Nostr: <span id="nostr-status" style="color: red;">Disconnected</span> |
        Index: <span id="index-count">0</span> books |
        Library: <span id="library-count">0</span> books
    </div>

    <!-- PEERJS BOX -->
    <div class="box">
        <h2>üîó PeerJS</h2>
        <div class="row" style="align-items:center;">
            <div>
                <strong>Your Peer ID:</strong>
                <code id="localId">Initialising‚Ä¶</code>
                <button id="copyIdBtn" class="secondary icon-button" type="button" aria-label="Copy peer ID" title="Copy peer ID" disabled>
                    <span aria-hidden="true">üìã</span>
                </button>
            </div>
        </div>
        <div class="row">
            <input type="text" id="remoteId" placeholder="Remote peer ID">
            <button id="connectBtn" class="secondary" type="button" disabled>Connect</button>
        </div>
        <div class="status" id="peer-status">Initialising PeerJS‚Ä¶</div>
    </div>

    <!-- NOSTR CONFIG BOX -->
    <div class="box">
        <h2>üîë Nostr Config (testing)</h2>
        <div>
            <button id="connect-btn" onclick="toggleNostrConnection()">Disconnect</button>
            <button onclick="nextRelay()">Next Relay</button>
            <button onclick="generateKeypair()">New Keypair</button>
        </div>
        <div style="margin-top: 10px; font-size: 12px;">
            <div><strong>Pubkey:</strong> <code id="pubkey" style="word-break: break-all;">-</code></div>
            <div style="margin-top: 5px;"><strong>Privkey:</strong> <code id="privkey" style="word-break: break-all;">-</code></div>
        </div>
    </div>

    <!-- SEARCH BOX -->
    <div class="box">
        <h2>üìñ Search</h2>
        <div>
            <input type="text" id="search-query" placeholder="Search for books..." value="dracula" onkeypress="if(event.key === 'Enter') searchBooks()">
            <button onclick="searchBooks()">Search Network</button>
        </div>
        <h3>Search Results</h3>
        <div id="search-results"></div>
        <h3>Network Activity</h3>
        <div class="log" id="search-log"></div>
    </div>

    <!-- SEARCH DAEMON DEBUG -->
    <div class="box">
        <h2>üîç Search Daemon - Debug</h2>
        <div class="log" id="search-daemon-log"></div>
    </div>

    <!-- LIBRARY BOX -->
    <div class="box">
        <h2>üìö My Library</h2>
        <div>
            <button onclick="addTestBook()">Add Test Book</button>
        </div>
        <div id="library" class="book-grid">
            <p>No books yet. Download some to get started!</p>
        </div>
    </div>

    <!-- TRANSFER BOX -->
    <div class="box">
        <h2>üì• Transfer Client</h2>
        <div>
            <input type="text" id="transfer-book-id" placeholder="Book ID">
            <button onclick="requestBook()">Request Book</button>
        </div>
        <div class="log" id="transfer-log"></div>
    </div>

    <!-- DAEMON CONTROLS -->
    <div class="box">
        <h2>ü§ñ Daemon Controls</h2>
        <div>
            <button onclick="loadIndex()">Load Index</button>
            <button onclick="forceLoadTestBooks()">Load 5 Test Books</button>
        </div>
        <div style="margin-top: 10px;">
            <label><input type="checkbox" id="search-daemon-enabled" checked> Search Daemon (auto-respond to queries)</label><br>
            <label><input type="checkbox" id="transfer-daemon-enabled" checked> Transfer Daemon (auto-serve books)</label>
        </div>
    </div>

    <!-- TRANSFER DAEMON DEBUG -->
    <div class="box">
        <h2>üì° Transfer Daemon - Debug</h2>
        <div class="log" id="transfer-daemon-log"></div>
    </div>

    <!-- P2P DEBUG -->
    <div class="box">
        <h2>üîç Peer Debug (detailed logs)</h2>
        <button onclick="document.getElementById('webrtc-debug').innerHTML = ''">Clear</button>
        <div class="log" id="webrtc-debug" style="font-family: monospace; font-size: 11px; max-height: 600px;"></div>
    </div>

    <script>
        // ===== STATE =====
        let ws = null;
        let books = []; // index
        let library = []; // downloaded books
        const relays = [
            'wss://relay.snort.social',
            'wss://nostr.wine',
            'wss://relay.nostr.band',
            'wss://nos.lol',           // Requires POW - skip for now
            'wss://relay.damus.io'     // Rate limits easily
        ];
        let currentRelayIndex = 0;
        let relay = relays[currentRelayIndex];
        let keypair = { pubkey: '', privkey: '' };
        let db = null;
        let mySearches = new Set(); // Track our own searches to match responses
        let answeredQueries = new Map(); // Track what we've answered: eventId -> timestamp
        let connectionCheckInterval = null; // Check connection status
        let searchResults = new Map(); // Track search results: bookId -> {book, peers: [pubkey]}
        let myWhoHasQueries = new Set(); // Track which book IDs we've asked "who has?" for
        let peer; // PeerJS instance
        let peerConnections = new Map(); // Track active PeerJS data connections: peerId -> DataConnection
        let incomingTransfers = new Map(); // Track incoming transfer state: key -> {chunks, totalChunks, title, author}
        let latestDemo = null; // Placeholder for compatibility with send button logic

        const localIdEl = document.getElementById('localId');
        const copyIdBtn = document.getElementById('copyIdBtn');
        const remoteIdEl = document.getElementById('remoteId');
        const connectBtn = document.getElementById('connectBtn');
        const sendBtn = document.getElementById('sendBtn');
        const fileInput = document.getElementById('fileInput');
        const peerStatusEl = document.getElementById('peer-status');
        const sourceRadios = document.querySelectorAll('input[name="sendSource"]');

        if (connectBtn) connectBtn.disabled = true;

        function setStatus(message) {
            if (peerStatusEl) {
                peerStatusEl.textContent = message;
            }
        }

        function getSelectedSource() {
            const selected = Array.from(sourceRadios || []).find((radio) => radio.checked);
            return selected ? selected.value : 'demo';
        }

        function hasActivePeerConnection() {
            for (const conn of peerConnections.values()) {
                if (conn.open) {
                    return true;
                }
            }
            return false;
        }

        function updateSendButtonState() {
            if (!sendBtn) return;
            if (!hasActivePeerConnection()) {
                sendBtn.disabled = true;
                return;
            }

            if (getSelectedSource() === 'demo') {
                sendBtn.disabled = !latestDemo;
            } else {
                const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;
                sendBtn.disabled = !hasFile;
            }
        }

        // ===== INDEXEDDB =====
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('GutenbergP2P', 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('library')) {
                        const store = db.createObjectStore('library', { keyPath: 'id' });
                        store.createIndex('title', 'title', { unique: false });
                    }
                };
            });
        }

        async function saveBookToDB(book) {
            if (!db) return;
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['library'], 'readwrite');
                const store = tx.objectStore('library');
                const request = store.put(book);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function loadLibraryFromDB() {
            if (!db) return [];
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['library'], 'readonly');
                const store = tx.objectStore('library');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteBookFromDB(id) {
            if (!db) return;
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['library'], 'readwrite');
                const store = tx.objectStore('library');
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function forceLoadTestBooks() {
            // Force load test books (ignores existing library)
            await loadTestBooksImpl();
        }

        async function seedTestBooks() {
            // Add some test books to the library if empty
            if (library.length > 0) return;
            await loadTestBooksImpl();
        }

        async function loadTestBooksImpl() {

            const bookFiles = [
                { id: '11', title: "Alice's Adventures in Wonderland", author: 'Lewis Carroll', file: 'alice.txt' },
                { id: '1342', title: 'Pride and Prejudice', author: 'Jane Austen', file: 'pride.txt' },
                { id: '84', title: 'Frankenstein', author: 'Mary Wollstonecraft Shelley', file: 'frankenstein.txt' },
                { id: '345', title: 'Dracula', author: 'Bram Stoker', file: 'dracula.txt' },
                { id: '48320', title: 'Adventures of Sherlock Holmes', author: 'Arthur Conan Doyle', file: 'sherlock.txt' }
            ];

            let loaded = 0;
            let skipped = 0;

            for (const bookMeta of bookFiles) {
                // Skip if already in library
                if (library.find(b => b.id === bookMeta.id)) {
                    skipped++;
                    console.log(`[SEED] Skipping ${bookMeta.title} - already in library`);
                    continue;
                }

                try {
                    const response = await fetch(bookMeta.file);
                    if (!response.ok) continue;
                    const content = await response.text();

                    const book = {
                        id: bookMeta.id,
                        title: bookMeta.title,
                        author: bookMeta.author,
                        content: content
                    };

                    await saveBookToDB(book);
                    library.push(book);
                    loaded++;
                } catch (e) {
                    console.log(`[SEED] Could not load ${bookMeta.file}: ${e.message}`);
                }
            }

            renderLibrary();
            document.getElementById('library-count').textContent = library.length;
            log('transfer-log', `Loaded ${loaded} books (${skipped} already present)`, 'answer');
        }

        // ===== LOGGING =====
        function logDebug(label, data) {
            const container = document.getElementById('webrtc-debug');
            if (!container) return;

            const div = document.createElement('div');
            div.style.marginBottom = '10px';
            div.style.padding = '8px';
            div.style.background = '#f5f5f5';
            div.style.border = '1px solid #ddd';
            div.style.borderRadius = '3px';

            const time = new Date().toLocaleTimeString();
            const labelSpan = document.createElement('div');
            labelSpan.style.fontWeight = 'bold';
            labelSpan.style.color = '#0066cc';
            labelSpan.textContent = `[${time}] ${label}`;

            const pre = document.createElement('pre');
            pre.style.margin = '5px 0 0 0';
            pre.style.whiteSpace = 'pre-wrap';
            pre.style.fontSize = '10px';
            pre.textContent = JSON.stringify(data, null, 2);

            div.appendChild(labelSpan);
            div.appendChild(pre);
            container.prepend(div);
        }

        function log(boxId, msg, type = '') {
            console.log(`[LOG] ${boxId}: ${msg}`);
            const container = document.getElementById(boxId);
            if (!container) {
                console.error(`[LOG ERROR] Container not found: ${boxId}`);
                return;
            }
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            container.prepend(div);
        }

        // ===== NOSTR CONNECTION =====
        function toggleNostrConnection() {
            if (ws) {
                disconnectNostr();
            } else {
                connectNostr();
            }
        }

        function nextRelay() {
            log('search-daemon-log', 'Switching to next relay...', 'query');
            if (ws) disconnectNostr();
            currentRelayIndex = (currentRelayIndex + 1) % relays.length;
            relay = relays[currentRelayIndex];
            setTimeout(() => connectNostr(), 500);
        }

        function connectNostr() {
            if (ws) {
                log('search-daemon-log', 'Already connected');
                return;
            }

            log('search-daemon-log', `Connecting to ${relay}...`);
            ws = new WebSocket(relay);

            ws.onopen = () => {
                const statusEl = document.getElementById('nostr-status');
                statusEl.textContent = `Connected (${relay.replace('wss://', '')})`;
                statusEl.style.color = 'green';
                const connectBtn = document.getElementById('connect-btn');
                if (connectBtn) connectBtn.textContent = 'Disconnect';
                log('search-daemon-log', `Connected to ${relay}!`, 'answer');

                // Subscribe to search queries and answers (only NEW events from now on)
                const now = Math.floor(Date.now() / 1000);
                const sub = JSON.stringify([
                    'REQ',
                    'gutenberg',
                    {
                        kinds: [25555, 25556, 25557, 25558, 25559, 25560], // search, metadata, who-has, offer, answer, ice
                        since: now // only events from now forward
                    }
                ]);
                ws.send(sub);
                log('search-daemon-log', 'Subscribed to TEST events (kinds 25555-25560)');

                // Check connection status every 5 seconds
                connectionCheckInterval = setInterval(() => {
                    if (ws) {
                        const states = {
                            0: { text: `Connecting... (${relay.replace('wss://', '')})`, color: 'orange' },
                            1: { text: `Connected (${relay.replace('wss://', '')})`, color: 'green' },
                            2: { text: 'Closing...', color: 'orange' },
                            3: { text: 'Disconnected', color: 'red' }
                        };
                        const status = states[ws.readyState] || { text: 'Unknown', color: 'gray' };
                        const statusEl = document.getElementById('nostr-status');
                        statusEl.textContent = status.text;
                        statusEl.style.color = status.color;

                        // Auto-reconnect if connection dropped
                        if (ws.readyState === 3) {
                            log('search-daemon-log', 'Connection lost, reconnecting...', 'query');
                            setTimeout(connectNostr, 2000);
                        }
                    }
                }, 5000);
            };

            ws.onmessage = async (event) => {
                const msg = JSON.parse(event.data);
                console.log('[NOSTR RECEIVED]', msg);

                if (msg[0] === 'EVENT') {
                    const ev = msg[2];
                    console.log('[EVENT RECEIVED] Kind:', ev.kind, 'Content:', ev.content);
                    handleNostrEvent(ev);
                }

                // EOSE = End Of Stored Events (confirms subscription is active)
                if (msg[0] === 'EOSE') {
                    log('search-daemon-log', '‚úì Listening for events on network', 'answer');
                }

                // OK response to our events
                if (msg[0] === 'OK') {
                    console.log('[EVENT ACCEPTED]', msg);
                    // Check for rate limiting
                    if (msg[2] === false && msg[3] && msg[3].includes('rate-limit')) {
                        log('search-daemon-log', `‚ö†Ô∏è Rate limited by ${relay}, switching relay...`, 'query');
                        disconnectNostr();
                        setTimeout(() => {
                            currentRelayIndex = (currentRelayIndex + 1) % relays.length;
                            relay = relays[currentRelayIndex];
                            connectNostr();
                        }, 1000);
                    }
                }
            };

            ws.onerror = () => {
                log('search-daemon-log', `Connection error with ${relay}`, 'query');
            };

            ws.onclose = () => {
                const statusEl = document.getElementById('nostr-status');
                statusEl.textContent = 'Disconnected';
                statusEl.style.color = 'red';
                const connectBtn = document.getElementById('connect-btn');
                if (connectBtn) connectBtn.textContent = 'Connect to Nostr';
                log('search-daemon-log', 'Disconnected');

                // Clear connection check interval
                if (connectionCheckInterval) {
                    clearInterval(connectionCheckInterval);
                    connectionCheckInterval = null;
                }

                ws = null;

                // Try next relay after 2 seconds
                setTimeout(() => {
                    if (!ws) {
                        currentRelayIndex = (currentRelayIndex + 1) % relays.length;
                        relay = relays[currentRelayIndex];
                        log('search-daemon-log', `Trying next relay: ${relay}`, 'query');
                        connectNostr();
                    }
                }, 2000);
            };
        }

        function disconnectNostr() {
            if (!ws) {
                log('search-daemon-log', 'Not connected');
                return;
            }

            log('search-daemon-log', 'Disconnecting...');
            ws.close();
        }

        // ===== NOSTR EVENT HANDLER =====
        async function handleNostrEvent(ev) {
            const kind = ev.kind;

            // Search Query (kind 25555)
            if (kind === 25555) {
                const queryTag = ev.tags.find(t => t[0] === 'q');
                const query = queryTag ? queryTag[1] : '';
                const eventId = ev.id;
                const fromPubkey = ev.pubkey;

                // Show all queries in search log (real-time feed)
                const isOwnQuery = fromPubkey === keypair.pubkey;
                if (isOwnQuery) {
                    log('search-log', `üîÅ Your search echoed back: "${query}"`, 'answer');
                } else {
                    log('search-log', `üîç Network search: "${query}"`, 'query');
                }

                // DAEMON DECISION LOGIC
                if (document.getElementById('search-daemon-enabled').checked) {
                    log('search-daemon-log', `üì• Query received: "${query}" from ${fromPubkey.substring(0, 8)}...`, 'query');

                    // Decision 1: Skip if it's our own query
                    if (fromPubkey === keypair.pubkey) {
                        log('search-daemon-log', `‚è≠Ô∏è  Skip: Our own query`, 'query');
                        return;
                    }

                    // Decision 2: Skip if we already answered this exact event
                    if (answeredQueries.has(eventId)) {
                        log('search-daemon-log', `‚è≠Ô∏è  Skip: Already answered`, 'query');
                        return;
                    }

                    // Decision 3: Skip if we don't have the index loaded
                    if (books.length === 0) {
                        log('search-daemon-log', `‚è≠Ô∏è  Skip: Index not loaded`, 'query');
                        return;
                    }

                    // Decision 4: Search for matches
                    const matches = books.filter(b =>
                        b.title.toLowerCase().includes(query.toLowerCase()) ||
                        b.id === query
                    ).slice(0, 5);

                    if (matches.length > 0) {
                        log('search-daemon-log', `‚úì Found ${matches.length} match(es), responding...`, 'answer');

                        // Mark as answered
                        answeredQueries.set(eventId, Date.now());

                        // Respond after a small delay
                        setTimeout(() => {
                            matches.forEach(book => {
                                sendSearchAnswer(book);
                            });
                        }, 500);

                        // Clean up old answered queries after 5 minutes
                        setTimeout(() => answeredQueries.delete(eventId), 300000);
                    } else {
                        log('search-daemon-log', `‚è≠Ô∏è  Skip: No matches found`, 'query');
                    }
                }
            }

            // Search Answer (kind 25556) - metadata only
            if (kind === 25556) {
                const idTag = ev.tags.find(t => t[0] === 'id');
                const titleTag = ev.tags.find(t => t[0] === 'title');
                const authorTag = ev.tags.find(t => t[0] === 'author');
                const id = idTag ? idTag[1] : 'unknown';
                const title = titleTag ? titleTag[1] : 'unknown';
                const author = authorTag ? authorTag[1] : 'Unknown';

                // Check if this is a response to our search
                const isMyResult = Array.from(mySearches).some(query =>
                    title.toLowerCase().includes(query.toLowerCase()) ||
                    id === query
                );

                if (isMyResult) {
                    log('search-log', `‚úì Metadata: "${title}" (${id})`, 'answer');
                    console.log('[SEARCH RESULT] Adding to results:', id, title);

                    // Add to search results (metadata only, no peers yet)
                    if (!searchResults.has(id)) {
                        searchResults.set(id, {
                            id: id,
                            title: title,
                            author: author,
                            peers: [],
                            peerTransports: {},
                            peerPeerIds: {},
                            completedPeers: []
                        });
                        console.log('[SEARCH RESULT] Now have', searchResults.size, 'results');
                        renderSearchResults();
                    }
                } else {
                    log('search-log', `‚Üê Found: "${title}" (${id})`, 'answer');
                }
            }

            // "Who has?" Query (kind 25557)
            if (kind === 25557) {
                const idTag = ev.tags.find(t => t[0] === 'id');
                const bookId = idTag ? idTag[1] : '';
                const fromPubkey = ev.pubkey;

                log('search-daemon-log', `üì• "Who has ${bookId}?" from ${fromPubkey.substring(0, 8)}...`, 'query');

                // Check if we have this book in our library
                if (document.getElementById('transfer-daemon-enabled').checked) {
                    const haveIt = library.find(b => b.id === bookId);
                    if (haveIt) {
                        log('transfer-daemon-log', `‚úì We have it! Announcing transports...`, 'answer');
                        setTimeout(() => announceAvailability(bookId, fromPubkey), 500);
                    } else {
                        log('transfer-daemon-log', `‚è≠Ô∏è  Skip: Don't have file ${bookId}`, 'query');
                    }
                }
            }

            // "I have it" Answer (kind 25558) - includes transports/PeerJS metadata
            if (kind === 25558) {
                const idTag = ev.tags.find(t => t[0] === 'id');
                const toTag = ev.tags.find(t => t[0] === 'to');
                const transportsTag = ev.tags.find(t => t[0] === 'transports');
                const peerTag = ev.tags.find(t => t[0] === 'peer');
                const bookId = idTag ? idTag[1] : '';
                const fromPubkey = ev.pubkey;

                // Check if this message is for us
                const isForUs = toTag && toTag[1] === keypair.pubkey;

                // Check if this is for a book we asked about
                if (myWhoHasQueries.has(bookId) || isForUs) {
                    const transports = transportsTag ? JSON.parse(transportsTag[1]) : [];
                    const transportStr = transports.length > 0 ? ` (${transports.join(', ')})` : '';
                    log('search-log', `‚úì Peer ${fromPubkey.substring(0, 8)}... has file ${bookId}${transportStr}`, 'answer');

                    // Add peer to search results with transports
                    const result = searchResults.get(bookId);
                    if (result) {
                        if (!result.peers) result.peers = [];
                        if (!result.peerTransports) result.peerTransports = {};
                        if (!result.peerPeerIds) result.peerPeerIds = {};

                        if (!result.peers.includes(fromPubkey)) {
                            result.peers.push(fromPubkey);
                        }

                        // Store available transports for this peer
                        if (transports.length > 0) {
                            result.peerTransports[fromPubkey] = transports;
                        }

                        if (peerTag) {
                            result.peerPeerIds[fromPubkey] = peerTag[1];
                        }

                        renderSearchResults();
                    }
                }
            }

            // Legacy WebRTC-related events (25559/25560/25561) are ignored in the PeerJS version
        }

        // ===== LOAD INDEX =====
        async function loadIndex() {
            log('search-daemon-log', 'Downloading index... (~9 MB)', 'query');

            try {
                const response = await fetch('GUTINDEX.ALL.new');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                log('search-daemon-log', 'Download complete! Parsing...', 'answer');
                const text = await response.text();
                const lines = text.split('\n');

                console.log('[INDEX] Total lines:', lines.length);
                console.log('[INDEX] First 5 lines:', lines.slice(0, 5));
                console.log('[INDEX] Sample line 100000:', lines[100000]);

                books = [];
                let current = null;
                let matchCount = 0;

                for (const line of lines) {
                    const match = line.match(/^(.+?)\s{2,}(\d+)\r?$/); // Handle CRLF
                    if (match) {
                        matchCount++;
                        if (matchCount <= 5) {
                            console.log('[INDEX] Match:', match[0]);
                        }
                        if (current) books.push(current);

                        const content = match[1].trim();
                        const id = match[2];

                        let title, author;
                        if (content.includes(', by ')) {
                            [title, author] = content.split(', by ', 2);
                        } else {
                            title = content;
                            author = 'Unknown';
                        }

                        current = { id, title, author };
                    }
                }

                if (current) books.push(current);

                console.log('[INDEX] Total matches found:', matchCount);
                console.log('[INDEX] Books array length:', books.length);

                document.getElementById('index-count').textContent = books.length;
                log('search-daemon-log', `Loaded ${books.length} books`, 'answer');
            } catch (e) {
                log('search-daemon-log', `Failed to load index: ${e.message}`, 'query');
            }
        }

        // ===== FILL CDN =====
        function fillCDN() {
            log('transfer-daemon-log', 'Fill CDN not yet implemented (for later)', 'transfer');
            // TODO: Download random books from network to become a seeder
        }

        // ===== SEARCH =====
        async function searchBooks() {
            console.log('[DEBUG] searchBooks() called');

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('search-log', 'Not connected, connecting...', 'query');
                console.log('[DEBUG] Auto-connecting...');
                connectNostr();
                // Wait a bit for connection then retry
                setTimeout(searchBooks, 1500);
                return;
            }

            console.log('[DEBUG] WebSocket state:', ws.readyState);

            const query = document.getElementById('search-query').value.trim();
            console.log('[DEBUG] Query:', query);

            if (!query) {
                log('search-log', '‚ö†Ô∏è Please enter a search term', 'query');
                return;
            }

            // Track this search so we can identify responses
            mySearches.add(query);

            const event = await makeEvent(25555, [['q', query]], `Searching for: ${query}`);
            console.log('[DEBUG] Sending event:', event);

            ws.send(JSON.stringify(['EVENT', event]));

            log('search-log', `‚Üí üîé YOU SEARCHED: "${query}" - waiting for responses...`, 'query');
            document.getElementById('search-query').value = '';

            // Clear old searches after 60 seconds
            setTimeout(() => mySearches.delete(query), 60000);

            // Clear previous search results
            searchResults.clear();
            renderSearchResults();
        }

        function renderSearchResults() {
            const container = document.getElementById('search-results');
            if (searchResults.size === 0) {
                container.innerHTML = '<p style="color: #666;">No results yet. Search for a book and wait for metadata responses.</p>';
                return;
            }

            let html = '';
            for (const [bookId, result] of searchResults) {
                const hasPeers = result.peers && result.peers.length > 0;
                const completedPeers = result.completedPeers || [];

                html += `
                    <div class="search-result">
                        <h4>${result.title}</h4>
                        <div>by ${result.author} | ID: ${result.id}</div>
                        ${hasPeers ? `
                            <div class="peer">Available from ${result.peers.length} peer(s)</div>
                            ${result.peers.map(peer => {
                                const isCompleted = completedPeers.includes(peer);
                                const transports = result.peerTransports && result.peerTransports[peer] ? result.peerTransports[peer] : [];

                                if (isCompleted) {
                                    return `<button class="completed" disabled>‚úì Received from ${peer.substring(0, 8)}...</button>`;
                                }

                                // Show one button per transport
                                if (transports.length > 0) {
                                    return transports.map(transport => {
                                        const label = transport === 'peerjs' ? 'PeerJS' : transport;
                                        return `
                                            <button onclick="requestTransfer('${result.id}', '${peer}', '${transport}')">
                                                ${peer.substring(0, 8)}... via ${label}
                                            </button>
                                        `;
                                    }).join('');
                                } else {
                                    // Fallback if no transports specified
                                    return `<button onclick="requestTransfer('${result.id}', '${peer}')">Request from ${peer.substring(0, 8)}...</button>`;
                                }
                            }).join('')}
                        ` : `
                            <button class="neutral" onclick="askWhoHas('${result.id}')">Who has this?</button>
                        `}
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        async function askWhoHas(bookId) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('search-log', '‚ùå Not connected to Nostr!', 'query');
                return;
            }

            myWhoHasQueries.add(bookId);

            const event = await makeEvent(
                25557,
                [['id', bookId]],
                `Who has file ${bookId}?`
            );

            ws.send(JSON.stringify(['EVENT', event]));
            log('search-log', `‚Üí Asking: "Who has file ${bookId}?"`, 'query');

            // Clear after 60 seconds
            setTimeout(() => myWhoHasQueries.delete(bookId), 60000);
        }

        async function announceAvailability(bookId, targetPubkey) {
            if (!ws) return;

            // Announce available transports
            if (!peer || !peer.id) {
                log('transfer-daemon-log', '‚ùå PeerJS not ready; cannot announce availability.', 'transfer');
                return;
            }

            const transports = ['peerjs'];

            const event = await makeEvent(
                25558,
                [
                    ['id', bookId],
                    ['to', targetPubkey],
                    ['transports', JSON.stringify(transports)],
                    ['peer', peer.id]
                ],
                `I have file ${bookId}`
            );

            ws.send(JSON.stringify(['EVENT', event]));
            log('transfer-daemon-log', `‚Üí Announced: ${transports.join(', ')}`, 'answer');
        }

        /* Legacy WebRTC implementation retained for reference
        async function sendIHaveIt(bookId, targetPubkey) {
            if (!ws) return;

            try {
                // Create WebRTC peer connection as answerer (will send offer, confusingly)
                const connectionId = `${keypair.pubkey}-${targetPubkey}-${bookId}`;
                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                peerConnections.set(connectionId, pc);
                pendingTransfers.set(connectionId, { bookId, peer: targetPubkey, role: 'sender' });

                // Track ICE candidates for logging
                const iceCandidates = [];

                // Monitor connection states
                pc.onconnectionstatechange = () => {
                    console.log('[SENDER PC] Connection state:', pc.connectionState);
                    log('transfer-daemon-log', `Sender connection state: ${pc.connectionState}`, 'answer');
                    logDebug('SENDER: Connection State', { state: pc.connectionState });
                };
                pc.oniceconnectionstatechange = () => {
                    console.log('[SENDER PC] ICE connection state:', pc.iceConnectionState);
                    log('transfer-daemon-log', `Sender ICE state: ${pc.iceConnectionState}`, 'answer');
                    logDebug('SENDER: ICE Connection State', { state: pc.iceConnectionState });
                };
                pc.onicegatheringstatechange = () => {
                    console.log('[SENDER PC] ICE gathering state:', pc.iceGatheringState);
                };

                // Create data channel for sending the book (with buffering enabled)
                const channel = pc.createDataChannel('book-transfer', {
                    ordered: true
                });

                channel.onopen = () => {
                    console.log('[SENDER CHANNEL] onopen fired, channel state:', channel.readyState, 'pc state:', pc.connectionState);
                    log('transfer-daemon-log', `üì° Data channel open (PC state: ${pc.connectionState}), waiting for receiver...`, 'answer');
                    // Wait for peer connection to fully establish
                    const checkAndSend = () => {
                        console.log('[CHECK] Channel:', channel.readyState, 'PC:', pc.connectionState, 'ICE:', pc.iceConnectionState);
                        if (channel.readyState === 'open' && (pc.connectionState === 'connected' || pc.iceConnectionState === 'connected')) {
                            log('transfer-daemon-log', `‚Üí Connection ready, sending book ${bookId}...`, 'answer');
                            sendBookData(channel, bookId);
                        } else if (channel.readyState === 'open') {
                            log('transfer-daemon-log', `‚è≥ Waiting for connection... (PC: ${pc.connectionState}, ICE: ${pc.iceConnectionState})`, 'answer');
                            setTimeout(checkAndSend, 1000);
                        } else {
                            log('transfer-daemon-log', `‚ùå Channel closed before sending`, 'transfer');
                        }
                    };
                    setTimeout(checkAndSend, 1000);
                };

                // Handle ICE candidates
                pc.onicecandidate = async (event) => {
                    if (event.candidate) {
                        iceCandidates.push(event.candidate);
                        const candData = {
                            type: event.candidate.type,
                            protocol: event.candidate.protocol,
                            address: event.candidate.address,
                            port: event.candidate.port,
                            candidate: event.candidate.candidate
                        };
                        console.log('[SENDER ICE] Candidate gathered:', candData);
                        logDebug('SENDER: ICE Candidate', candData);
                        const iceEvent = await makeEvent(
                            25560,
                            [
                                ['conn', connectionId],
                                ['candidate', JSON.stringify(event.candidate)],
                                ['to', targetPubkey]
                            ],
                            'ICE candidate'
                        );
                        ws.send(JSON.stringify(['EVENT', iceEvent]));
                    } else {
                        console.log('[SENDER ICE] Gathering complete. Total candidates:', iceCandidates.length);
                    }
                };

                // Create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                const offerData = {
                    connectionId: connectionId,
                    peerId: keypair.pubkey.substring(0, 16) + '...',
                    targetPeerId: targetPubkey.substring(0, 16) + '...',
                    sdpType: offer.type,
                    sdpPreview: offer.sdp.substring(0, 200) + '...'
                };
                console.log('[SENDER OFFER] Created offer:', offerData);
                logDebug('SENDER: Created Offer', offerData);

                // Send offer via Nostr (kind 25558)
                const event = await makeEvent(
                    25558,
                    [
                        ['id', bookId],
                        ['to', targetPubkey],
                        ['conn', connectionId],
                        ['offer', JSON.stringify(offer)]
                    ],
                    `I have file ${bookId}`
                );

                ws.send(JSON.stringify(['EVENT', event]));
                log('transfer-daemon-log', `‚Üí Sent offer for book ${bookId}`, 'answer');
            } catch (e) {
                log('transfer-daemon-log', `‚ùå Error creating offer: ${e.message}`, 'transfer');
            }
        }

        async function handleWebRTCOffer(offer, connectionId, bookId, fromPubkey) {
            try {
                log('transfer-log', `üì• Received WebRTC offer for book ${bookId}`, 'transfer');

                const receivedOfferData = {
                    connectionId: connectionId,
                    peerId: keypair.pubkey.substring(0, 16) + '...',
                    fromPeerId: fromPubkey.substring(0, 16) + '...',
                    sdpType: offer.type,
                    sdpPreview: offer.sdp.substring(0, 200) + '...'
                };
                console.log('[RECEIVER OFFER] Received offer:', receivedOfferData);
                logDebug('RECEIVER: Received Offer', receivedOfferData);

                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                peerConnections.set(connectionId, pc);
                pendingTransfers.set(connectionId, { bookId, peer: fromPubkey, role: 'receiver' });

                // Track ICE candidates for logging
                const iceCandidates = [];

                // Monitor connection states
                pc.onconnectionstatechange = () => {
                    console.log('[RECEIVER PC] Connection state:', pc.connectionState);
                    log('transfer-log', `Receiver connection state: ${pc.connectionState}`, 'answer');
                    logDebug('RECEIVER: Connection State', { state: pc.connectionState });
                };
                pc.oniceconnectionstatechange = () => {
                    console.log('[RECEIVER PC] ICE connection state:', pc.iceConnectionState);
                    log('transfer-log', `Receiver ICE state: ${pc.iceConnectionState}`, 'answer');
                    logDebug('RECEIVER: ICE Connection State', { state: pc.iceConnectionState });
                };
                pc.onicegatheringstatechange = () => {
                    console.log('[RECEIVER PC] ICE gathering state:', pc.iceGatheringState);
                };

                // Handle incoming data channel
                pc.ondatachannel = (event) => {
                    console.log('[ONDATACHANNEL] Event fired!', event);
                    const channel = event.channel;
                    console.log('[ONDATACHANNEL] Channel state:', channel.readyState);
                    log('transfer-log', `üì° Data channel event, state: ${channel.readyState}`, 'answer');

                    // Set up handlers immediately, before channel opens
                    let receivedData = '';
                    let messageCount = 0;

                    channel.onmessage = (e) => {
                        messageCount++;
                        console.log(`[CHANNEL ONMESSAGE #${messageCount}] Received data, length:`, e.data.length);
                        log('transfer-log', `üì• Received chunk #${messageCount}: ${e.data.length} bytes`, 'answer');
                        logDebug('RECEIVER: Data Received', { chunk: messageCount, bytes: e.data.length });
                        receivedData += e.data;
                    };

                    console.log('[CHANNEL] Set up onmessage handler, channel state:', channel.readyState);
                    logDebug('RECEIVER: Data Channel Ready', { state: channel.readyState, label: channel.label });

                    channel.onclose = async () => {
                        console.log(`[CHANNEL ONCLOSE] Channel closed, received ${messageCount} messages, total ${receivedData.length} bytes`);
                        log('transfer-log', `Channel closed, total received: ${receivedData.length} bytes (${messageCount} messages)`, 'answer');
                        logDebug('RECEIVER: Channel Closed', { messageCount, totalBytes: receivedData.length });
                        try {
                            const book = JSON.parse(receivedData);
                            log('transfer-log', `‚úì Received book: ${book.title} (${receivedData.length} bytes)`, 'answer');

                            await saveBookToDB(book);
                            library.push(book);
                            renderLibrary();
                            document.getElementById('library-count').textContent = library.length;

                            // Mark transfer as completed in search results
                            const result = searchResults.get(bookId);
                            if (result) {
                                if (!result.completedPeers) result.completedPeers = [];
                                result.completedPeers.push(fromPubkey);
                                renderSearchResults();
                            }

                            log('transfer-log', `‚úì Saved to library!`, 'answer');
                        } catch (e) {
                            log('transfer-log', `‚ùå Error saving book: ${e.message}`, 'transfer');
                            console.error('[RECEIVE ERROR]', e, 'Data length:', receivedData.length);
                        }
                    };

                    channel.onerror = (error) => {
                        log('transfer-log', `‚ùå Channel error: ${error}`, 'transfer');
                    };

                    channel.onopen = () => {
                        log('transfer-log', `‚úì Data channel fully open`, 'answer');
                    };
                };

                // Handle ICE candidates
                pc.onicecandidate = async (event) => {
                    if (event.candidate) {
                        iceCandidates.push(event.candidate);
                        const candData = {
                            type: event.candidate.type,
                            protocol: event.candidate.protocol,
                            address: event.candidate.address,
                            port: event.candidate.port,
                            candidate: event.candidate.candidate
                        };
                        console.log('[RECEIVER ICE] Candidate gathered:', candData);
                        logDebug('RECEIVER: ICE Candidate', candData);
                        const iceEvent = await makeEvent(
                            25560,
                            [
                                ['conn', connectionId],
                                ['candidate', JSON.stringify(event.candidate)],
                                ['to', fromPubkey]
                            ],
                            'ICE candidate'
                        );
                        ws.send(JSON.stringify(['EVENT', iceEvent]));
                    } else {
                        console.log('[RECEIVER ICE] Gathering complete. Total candidates:', iceCandidates.length);
                    }
                };

                // Set remote description and create answer
                await pc.setRemoteDescription(offer);

                // Process any queued ICE candidates
                if (pendingIceCandidates.has(connectionId)) {
                    const candidates = pendingIceCandidates.get(connectionId);
                    console.log(`[RECEIVER] Processing ${candidates.length} queued ICE candidates`);
                    logDebug('RECEIVER: Processing Queued ICE', { count: candidates.length });
                    for (const candidate of candidates) {
                        await pc.addIceCandidate(candidate);
                    }
                    pendingIceCandidates.delete(connectionId);
                } else {
                    console.log('[RECEIVER] No queued ICE candidates');
                    logDebug('RECEIVER: No Queued ICE', {});
                }

                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                const answerData = {
                    connectionId: connectionId,
                    sdpType: answer.type,
                    sdpPreview: answer.sdp.substring(0, 200) + '...'
                };
                console.log('[RECEIVER ANSWER] Created answer:', answerData);
                logDebug('RECEIVER: Created Answer', answerData);

                // Send answer via Nostr (kind 25559)
                const event = await makeEvent(
                    25559,
                    [
                        ['conn', connectionId],
                        ['answer', JSON.stringify(answer)],
                        ['to', fromPubkey]
                    ],
                    'WebRTC answer'
                );

                ws.send(JSON.stringify(['EVENT', event]));
                log('transfer-log', `‚Üí Sent WebRTC answer`, 'answer');
            } catch (e) {
                log('transfer-log', `‚ùå Error handling offer: ${e.message}`, 'transfer');
            }
        }

        function sendBookData(channel, bookId) {
            const book = library.find(b => b.id === bookId);
            if (!book) {
                log('transfer-daemon-log', `‚ùå Book ${bookId} not found in library`, 'transfer');
                return;
            }

            console.log('[SEND] Channel state before send:', channel.readyState);
            console.log('[SEND] Channel bufferedAmount:', channel.bufferedAmount);

            const data = JSON.stringify(book);
            console.log('[SEND] Data size:', data.length);

            // Chunk the data into smaller pieces (256KB chunks)
            const CHUNK_SIZE = 256 * 1024; // 256KB
            const chunks = [];
            for (let i = 0; i < data.length; i += CHUNK_SIZE) {
                chunks.push(data.slice(i, i + CHUNK_SIZE));
            }

            console.log(`[SEND] Splitting into ${chunks.length} chunks`);
            logDebug('SENDER: Chunking Data', { totalBytes: data.length, chunks: chunks.length, chunkSize: CHUNK_SIZE });

            try {
                // Send each chunk
                for (let i = 0; i < chunks.length; i++) {
                    channel.send(chunks[i]);
                    console.log(`[SEND] Sent chunk ${i + 1}/${chunks.length} (${chunks[i].length} bytes)`);
                }
                console.log('[SEND] All chunks sent successfully');
                console.log('[SEND] Buffered after send:', channel.bufferedAmount);
                log('transfer-daemon-log', `‚úì Sent book ${bookId} (${data.length} bytes in ${chunks.length} chunks)`, 'answer');

                // Close channel after data is buffered and sent
                setTimeout(() => {
                    console.log('[SEND] Closing channel, buffered:', channel.bufferedAmount);
                    logDebug('SENDER: Closing Channel', { bufferedAmount: channel.bufferedAmount });
                    channel.close();
                }, 3000);
            } catch (e) {
                console.error('[SEND ERROR]', e);
                log('transfer-daemon-log', `‚ùå Send error: ${e.message}`, 'transfer');
            }
        }

        function receiveBookData(channel, bookId) {
            let receivedData = '';

            log('transfer-log', `Setting up receive handlers for channel state: ${channel.readyState}`, 'transfer');

            channel.onmessage = (event) => {
                log('transfer-log', `üì• Received chunk: ${event.data.length} bytes`, 'answer');
                receivedData += event.data;
            };

            channel.onclose = async () => {
                log('transfer-log', `Channel closed, total received: ${receivedData.length} bytes`, 'answer');
                try {
                    const book = JSON.parse(receivedData);
                    log('transfer-log', `‚úì Received book: ${book.title} (${receivedData.length} bytes)`, 'answer');

                    // Save to library
                    await saveBookToDB(book);
                    library.push(book);
                    renderLibrary();
                    document.getElementById('library-count').textContent = library.length;

                    log('transfer-log', `‚úì Saved to library!`, 'answer');
                } catch (e) {
                    log('transfer-log', `‚ùå Error saving book: ${e.message}`, 'transfer');
                    console.error('[RECEIVE ERROR]', e, 'Data length:', receivedData.length);
                }
            };

            channel.onerror = (error) => {
                log('transfer-log', `‚ùå Channel error: ${error}`, 'transfer');
            };
        }
        */

        async function requestTransfer(bookId, peerPubkey, transport) {
            console.log('[REQUEST TRANSFER] Called with:', { bookId, peerPubkey: peerPubkey.substring(0, 16), transport });
            log('transfer-log', `‚Üí Requesting ${bookId} from ${peerPubkey.substring(0, 8)}... via ${transport || 'default'}`, 'query');
            logDebug('REQUEST: Starting Transfer', { bookId, peer: peerPubkey.substring(0, 16) + '...', transport });

            if (transport && transport !== 'peerjs') {
                log('transfer-log', `‚ùå Unsupported transport: ${transport}`, 'transfer');
                return;
            }

            startPeerJsTransfer(bookId, peerPubkey);
        }

        async function sendSearchAnswer(book) {
            const event = await makeEvent(
                25556,
                [
                    ['id', book.id],
                    ['title', book.title],
                    ['author', book.author || 'Unknown']
                ],
                `I have: ${book.title}`
            );
            ws.send(JSON.stringify(['EVENT', event]));
            log('search-daemon-log', `‚Üí Answered: ${book.title} (${book.id})`, 'answer');
        }

        function getPeerTransferKey(peerId, bookId) {
            return `${peerId}::${bookId}`;
        }

        function setupPeerConnection(conn, context = {}) {
            const remoteId = conn.peer;
            conn._context = context;
            peerConnections.set(remoteId, conn);

            conn.on('open', () => {
                log('transfer-log', `üîå PeerJS connection open with ${remoteId}`, 'answer');
                if (context.role === 'requester' && context.bookId) {
                    conn.send(JSON.stringify({ type: 'request', bookId: context.bookId, from: keypair.pubkey }));
                    log('transfer-log', `‚Üí Requested ${context.bookId} from ${context.peerPubkey ? context.peerPubkey.substring(0, 8) + '...' : remoteId}`, 'query');
                } else {
                    log('transfer-daemon-log', `üì° Incoming PeerJS connection from ${remoteId}`, 'answer');
                }
                setStatus('Connected to peer.');
                updateSendButtonState();
            });

            conn.on('data', (raw) => handlePeerMessage(conn, raw));

            conn.on('close', () => {
                peerConnections.delete(remoteId);
                updateSendButtonState();
                for (const key of Array.from(incomingTransfers.keys())) {
                    if (key.startsWith(`${remoteId}::`)) {
                        incomingTransfers.delete(key);
                    }
                }
                log('transfer-log', `Connection to ${remoteId} closed`, 'query');
                setStatus('Peer connection closed.');
            });

            conn.on('error', (err) => {
                log('transfer-log', `‚ùå Peer connection error: ${err?.message ?? err}`, 'transfer');
            });
        }

        function handlePeerMessage(conn, raw) {
            let msg;
            try {
                msg = JSON.parse(raw);
            } catch (err) {
                console.warn('[PEER] Non-JSON payload received:', raw);
                return;
            }

            switch (msg.type) {
                case 'request':
                    handlePeerRequest(conn, msg);
                    break;
                case 'meta':
                    prepareIncomingTransfer(conn, msg);
                    break;
                case 'chunk':
                    handleIncomingChunk(conn, msg);
                    break;
                case 'complete':
                    finalizeIncomingTransfer(conn, msg);
                    break;
                case 'error':
                    log('transfer-log', `‚ùå Peer error: ${msg.message}`, 'transfer');
                    break;
                default:
                    console.warn('[PEER] Unknown message type:', msg);
            }
        }

        const PEER_CHUNK_SIZE = 128 * 1024;

        function handlePeerRequest(conn, msg) {
            const { bookId, from } = msg;
            if (!bookId) {
                conn.send(JSON.stringify({ type: 'error', message: 'Missing bookId in request.' }));
                return;
            }

            if (conn._context) {
                conn._context.peerPubkey = from || conn._context.peerPubkey || null;
            } else {
                conn._context = { peerPubkey: from || null };
            }

            const transferEnabled = document.getElementById('transfer-daemon-enabled');
            if (transferEnabled && !transferEnabled.checked) {
                log('transfer-daemon-log', '‚è≠Ô∏è  Transfer daemon disabled, ignoring request.', 'query');
                conn.send(JSON.stringify({ type: 'error', bookId, message: 'Transfer daemon disabled.' }));
                return;
            }

            const book = library.find((b) => b.id === bookId);
            if (!book) {
                log('transfer-daemon-log', `‚ùå Book ${bookId} not found for request`, 'transfer');
                conn.send(JSON.stringify({ type: 'error', bookId, message: 'Book not available.' }));
                return;
            }

            log('transfer-daemon-log', `üì¶ Sending "${book.title}" to ${conn.peer}`, 'answer');
            sendBookOverPeer(conn, book);
        }

        function sendBookOverPeer(conn, book) {
            const data = JSON.stringify(book);
            const totalChunks = Math.max(1, Math.ceil(data.length / PEER_CHUNK_SIZE));

            conn.send(JSON.stringify({
                type: 'meta',
                bookId: book.id,
                title: book.title,
                author: book.author || 'Unknown',
                totalChunks,
                from: keypair.pubkey
            }));

            for (let i = 0; i < totalChunks; i++) {
                const chunk = data.slice(i * PEER_CHUNK_SIZE, (i + 1) * PEER_CHUNK_SIZE);
                conn.send(JSON.stringify({ type: 'chunk', bookId: book.id, index: i, chunk }));
            }

            conn.send(JSON.stringify({ type: 'complete', bookId: book.id }));
            log('transfer-daemon-log', `‚úì Sent "${book.title}" in ${totalChunks} chunks`, 'answer');
        }

        function prepareIncomingTransfer(conn, msg) {
            const key = getPeerTransferKey(conn.peer, msg.bookId);
            incomingTransfers.set(key, {
                chunks: new Array(msg.totalChunks).fill(''),
                totalChunks: msg.totalChunks,
                received: 0,
                title: msg.title,
                author: msg.author,
                peerPubkey: conn._context?.peerPubkey || msg.from || null
            });
            log('transfer-log', `üì¶ Incoming "${msg.title}" (${msg.totalChunks} chunks)`, 'answer');
            setStatus(`Receiving "${msg.title}"‚Ä¶`);
        }

        function handleIncomingChunk(conn, msg) {
            const key = getPeerTransferKey(conn.peer, msg.bookId);
            const transfer = incomingTransfers.get(key);
            if (!transfer) {
                console.warn('[PEER] Received chunk without transfer state', msg);
                return;
            }

            transfer.chunks[msg.index] = msg.chunk;
            transfer.received += 1;
            log('transfer-log', `üì• Chunk ${msg.index + 1}/${transfer.totalChunks} (${msg.chunk.length} bytes)`, 'answer');
        }

        async function finalizeIncomingTransfer(conn, msg) {
            const key = getPeerTransferKey(conn.peer, msg.bookId);
            const transfer = incomingTransfers.get(key);
            if (!transfer) {
                log('transfer-log', '‚ùå Transfer metadata missing; cannot finalize.', 'transfer');
                return;
            }

            const combined = transfer.chunks.join('');
            try {
                const book = JSON.parse(combined);
                await saveBookToDB(book);
                library.push(book);
                renderLibrary();
                document.getElementById('library-count').textContent = library.length;

                log('transfer-log', `‚úì Received "${book.title}" (${combined.length} bytes)`, 'answer');
                setStatus(`Received "${book.title}".`);

                const result = searchResults.get(book.id);
                if (result) {
                    if (!result.completedPeers) result.completedPeers = [];
                    const peerKey = transfer.peerPubkey;
                    if (peerKey && !result.completedPeers.includes(peerKey)) {
                        result.completedPeers.push(peerKey);
                        renderSearchResults();
                    }
                }
            } catch (e) {
                log('transfer-log', `‚ùå Error saving book: ${e.message}`, 'transfer');
                console.error('[PEER RECEIVE ERROR]', e, 'Data length:', combined.length);
            } finally {
                incomingTransfers.delete(key);
            }
        }

        function startPeerJsTransfer(bookId, peerPubkey) {
            if (!peer || peer.disconnected) {
                log('transfer-log', '‚ùå PeerJS not ready yet.', 'transfer');
                setStatus('PeerJS not ready yet.');
                return;
            }

            const result = searchResults.get(bookId);
            const peerId = result?.peerPeerIds?.[peerPubkey];
            if (!peerId) {
                log('transfer-log', '‚ùå Peer ID unavailable for this provider.', 'transfer');
                setStatus('Peer ID unavailable for this provider.');
                return;
            }

            log('transfer-log', `üîç Dialling ${peerPubkey.substring(0, 8)}...`, 'query');
            setStatus(`Connecting to provider ${peerPubkey.substring(0, 8)}‚Ä¶`);
            try {
                const conn = peer.connect(peerId, { reliable: true });
                setupPeerConnection(conn, { role: 'requester', bookId, peerPubkey });
            } catch (err) {
                log('transfer-log', `‚ùå PeerJS connection failed: ${err?.message ?? err}`, 'transfer');
                setStatus('PeerJS connection failed.');
            }
        }

        if (copyIdBtn) {
            copyIdBtn.addEventListener('click', () => {
                const id = localIdEl?.textContent?.trim();
                if (!id) {
                    setStatus('Peer ID unavailable to copy yet.');
                    return;
                }
                copyTextToClipboard(id, 'Peer ID copied to clipboard.');
            });
        }

        if (connectBtn) {
            connectBtn.addEventListener('click', () => {
                const remoteId = remoteIdEl?.value?.trim();
                if (!remoteId) {
                    setStatus('Enter a remote Peer ID first.');
                    return;
                }
                if (!peer || peer.disconnected) {
                    setStatus('PeerJS not ready yet.');
                    return;
                }
                if (remoteId === (peer.id || '')) {
                    setStatus('Use a partner\'s ID, not your own.');
                    return;
                }

                log('transfer-log', `üîó Opening PeerJS connection to ${remoteId}`, 'query');
                setStatus(`Connecting to ${remoteId}‚Ä¶`);
                try {
                    const conn = peer.connect(remoteId, { reliable: true });
                    setupPeerConnection(conn, { role: 'manual' });
                } catch (err) {
                    log('transfer-log', `‚ùå Connection failed: ${err?.message ?? err}`, 'transfer');
                }
            });
        }

        Array.from(sourceRadios).forEach((radio) => {
            radio.addEventListener('change', updateSendButtonState);
        });

        if (fileInput) {
            fileInput.addEventListener('change', updateSendButtonState);
        }

        updateSendButtonState();
        // ===== TRANSFER =====
        async function requestBook() {
            if (!ws) {
                log('transfer-log', 'Not connected to Nostr!', 'query');
                return;
            }

            const bookId = document.getElementById('transfer-book-id').value.trim();
            if (!bookId) return;

            const event = await makeEvent(25557, [['id', bookId]], `Requesting book: ${bookId}`);
            ws.send(JSON.stringify(['EVENT', event]));

            log('transfer-log', `‚Üí Requesting book ${bookId}`, 'transfer');
            document.getElementById('transfer-book-id').value = '';

            log('transfer-log', 'PeerJS transfer requested; awaiting peers...', 'query');
        }

        // ===== LIBRARY =====
        function renderLibrary() {
            const container = document.getElementById('library');

            if (library.length === 0) {
                container.innerHTML = '<p>No books yet. Download some to get started!</p>';
                return;
            }

            container.innerHTML = library.map(book => `
                <div class="book-card">
                    <h4>${book.title}</h4>
                    <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                        ${book.author}<br>
                        ID: ${book.id}
                    </div>
                    <button onclick="openBook('${book.id}')">Open</button>
                    <button onclick="saveBook('${book.id}')">Save</button>
                    <button onclick="deleteBook('${book.id}')">Delete</button>
                </div>
            `).join('');

            document.getElementById('library-count').textContent = library.length;
        }

        function openBook(id) {
            const book = library.find(b => b.id === id);
            if (!book) {
                log('transfer-log', `‚ùå Book ${id} not found`, 'transfer');
                return;
            }

            // Open book content in a new tab
            const newTab = window.open();
            newTab.document.write(`
                <html>
                <head>
                    <title>${book.title} - ${book.author}</title>
                    <style>
                        body { font-family: Georgia, serif; max-width: 800px; margin: 40px auto; padding: 20px; line-height: 1.6; }
                        h1 { font-size: 2em; margin-bottom: 0.5em; }
                        .author { color: #666; font-style: italic; margin-bottom: 2em; }
                        pre { white-space: pre-wrap; font-family: Georgia, serif; }
                    </style>
                </head>
                <body>
                    <h1>${book.title}</h1>
                    <div class="author">by ${book.author}</div>
                    <pre>${book.content}</pre>
                </body>
                </html>
            `);
            newTab.document.close();
            log('transfer-log', `‚úì Opened "${book.title}" in new tab`, 'answer');
        }

        function saveBook(id) {
            const book = library.find(b => b.id === id);
            if (!book) {
                log('transfer-log', `‚ùå Book ${id} not found`, 'transfer');
                return;
            }

            // Create a downloadable file
            const blob = new Blob([book.content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${book.title.replace(/[^a-z0-9]/gi, '_')}_${book.id}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            log('transfer-log', `‚úì Downloaded "${book.title}" to disk`, 'answer');
        }

        async function deleteBook(id) {
            library = library.filter(b => b.id !== id);
            await deleteBookFromDB(id);
            renderLibrary();
            log('transfer-log', `Deleted book ${id}`, 'query');
        }

        // Add a test book to library (for testing)
        async function addTestBook() {
            const testBook = {
                id: '1984',
                title: 'Nineteen Eighty-Four',
                author: 'George Orwell',
                data: 'Test book data...' // In real version, this would be the actual file
            };

            library.push(testBook);
            await saveBookToDB(testBook);
            renderLibrary();
            log('transfer-log', `Added test book: ${testBook.title}`, 'answer');
        }

        // ===== NOSTR KEYPAIR =====
        function generateKeypair() {
            try {
                const wasConnected = ws && ws.readyState === WebSocket.OPEN;

                // Use nostr-tools to generate proper keypair
                const sk = NostrTools.generateSecretKey();
                const pk = NostrTools.getPublicKey(sk);

                keypair.privkey = sk;
                keypair.pubkey = pk;

                // Convert to hex for display
                const skHex = Array.from(sk).map(b => b.toString(16).padStart(2, '0')).join('');
                const pkHex = pk;

                document.getElementById('pubkey').textContent = pkHex;
                document.getElementById('privkey').textContent = skHex;

                log('search-daemon-log', 'Generated new keypair', 'answer');

                // Reconnect if we were connected (to use new identity)
                if (wasConnected) {
                    log('search-daemon-log', 'Reconnecting with new identity...', 'answer');
                    disconnectNostr();
                    setTimeout(() => connectNostr(), 1000);
                }
            } catch (e) {
                console.error('[KEYPAIR ERROR]', e);
                log('search-daemon-log', 'Error generating keypair: ' + e.message, 'query');
            }
        }

        // ===== HELPERS =====
        async function makeEvent(kind, tags, content) {
            // Use nostr-tools finalizeEvent to create properly signed events
            const eventTemplate = {
                kind: kind,
                created_at: Math.floor(Date.now() / 1000),
                tags: tags,
                content: content
            };

            // finalizeEvent will add id, pubkey, and sig
            const signedEvent = NostrTools.finalizeEvent(eventTemplate, keypair.privkey);

            return signedEvent;
        }

        function randomHex(len) {
            return Array.from({length: len}, () =>
                Math.floor(Math.random() * 16).toString(16)
            ).join('');
        }

        async function copyTextToClipboard(text, successMessage) {
            try {
                await navigator.clipboard.writeText(text);
                if (successMessage) {
                    setStatus(successMessage);
                }
            } catch (err) {
                console.warn('[CLIPBOARD]', err);
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    if (successMessage) {
                        setStatus(successMessage);
                    }
                } catch (fallbackErr) {
                    console.error('[CLIPBOARD FALLBACK]', fallbackErr);
                    setStatus('Copy failed. Select and copy manually.');
                } finally {
                    document.body.removeChild(textarea);
                }
            }
        }

        async function initPeerJs() {
            if (!window.Peer) {
                setStatus('PeerJS script failed to load.');
                return;
            }

            return new Promise((resolve) => {
                setStatus('Initialising PeerJS‚Ä¶');
                const options = {
                    host: '0.peerjs.com',
                    port: 443,
                    path: '/',
                    secure: true,
                    key: 'peerjs'
                };

                peer = new window.Peer(undefined, options);

                peer.on('open', (id) => {
                    localIdEl.textContent = id;
                    localIdEl.title = 'Share this ID with your peer';
                    copyIdBtn.disabled = false;
                    connectBtn.disabled = false;
                    setStatus('Share your Peer ID, then connect to a partner.');
                    updateSendButtonState();
                    resolve();
                });

                peer.on('error', (err) => {
                    console.error('[PeerJS ERROR]', err);
                    setStatus(`PeerJS error: ${err?.type ?? err?.message ?? err}`);
                    resolve();
                });

                peer.on('connection', (conn) => {
                    setupPeerConnection(conn, { role: 'provider' });
                });
            });
        }

        // Initialize
        async function init() {
            await initDB();
            library = await loadLibraryFromDB();
            await seedTestBooks(); // Add test books if library is empty
            generateKeypair();
            renderLibrary();
            renderSearchResults();
            log('transfer-log', `Loaded ${library.length} books from storage`, 'answer');

            await initPeerJs();

            // Auto-connect to Nostr and load index
            connectNostr();
            loadIndex();
        }

        init();
    </script>
</body>
</html>
