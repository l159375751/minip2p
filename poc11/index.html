<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POC11 - Progressive Library Builder</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìö</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/webtorrent@latest/webtorrent.min.js"></script>
    <script src="library-builder.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-untar@2.0.0/build/dist/untar.js"></script>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border-left: 4px solid rgba(102, 126, 234, 0.5);
        }
        h1 {
            color: white;
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }
        .progress-container {
            background: #e8e8e8;
            border-radius: 0.25rem;
            height: 24px;
            overflow: hidden;
            margin: 0.75rem 0;
        }
        .progress-bar {
            background: #667eea;
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 500;
            font-size: 0.85rem;
        }
        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin: 1rem 0;
            padding: 0.75rem 0;
            border-top: 1px solid #e0e0e0;
            border-bottom: 1px solid #e0e0e0;
        }
        .stat {
            flex: 0 0 auto;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }
        .stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #333;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.25rem;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            width: 100%;
            transition: background 0.2s;
        }
        button:hover {
            background: #5568d3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .log {
            background: #f8f8f8;
            color: #333;
            padding: 0.75rem;
            border-radius: 0.25rem;
            max-height: 250px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.8rem;
            border: 1px solid #e0e0e0;
        }
        .log > div {
            padding: 0.25rem 0;
            border-bottom: 1px dotted #e0e0e0;
        }
        .log > div:last-child {
            border-bottom: none;
        }
        .book-list {
            max-height: 300px;
            overflow-y: auto;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 0.25rem;
            padding: 0.5rem;
        }
        .book-item {
            padding: 0.3rem 0.5rem;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.85rem;
            color: #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .book-item:last-child {
            border-bottom: none;
        }
        .book-item:hover {
            background: #f8f8f8;
        }
        .book-title {
            flex: 1;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .book-btn {
            background: transparent;
            color: #667eea;
            border: 1px solid #ddd;
            padding: 0.2rem 0.35rem;
            border-radius: 0.25rem;
            font-size: 0.9rem;
            cursor: pointer;
            white-space: nowrap;
            margin-left: 0.5rem;
            flex-shrink: 0;
        }
        .book-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
    </style>
</head>
<body>
    <h1>üìö Library</h1>

    <div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.9); border-radius: 0.5rem; border-left: 4px solid rgba(102, 126, 234, 0.5);">
        <div id="statusLine" style="font-size: 0.9rem; color: #666;">
            üìö Loading catalog...
        </div>
    </div>

    <details style="margin-bottom: 1rem;">
        <summary style="cursor: pointer; padding: 0.5rem; background: rgba(255,255,255,0.8); border-radius: 0.25rem; font-size: 0.9rem;">
            ‚öôÔ∏è Download Options
        </summary>
        <div style="margin-top: 0.5rem; padding: 1rem; background: rgba(255,255,255,0.95); border-radius: 0.5rem;">
            <input type="text" id="magnetInput" placeholder="magnet:?xt=urn:btih:..." value="magnet:?xt=urn:btih:a7bb7a777b775c6f7205e90b57c44b014a4e5f0c&dn=gutenberg-txt-files.tar.gz&tr=wss%3A%2F%2Ftracker.openwebtorrent.com&tr=wss%3A%2F%2Ftracker.btorrent.xyz&tr=wss%3A%2F%2Ftracker.webtorrent.dev"
                style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 0.25rem; font-family: monospace; font-size: 0.85rem; margin-bottom: 0.5rem;">
            <div style="display: flex; gap: 0.5rem;">
                <button onclick="startDownload()" style="flex: 1;">Start Download</button>
                <button onclick="document.getElementById('torrentFileInput').click()" style="flex: 0.8;">or .torrent</button>
                <button onclick="document.getElementById('localFileInput').click()" style="flex: 1;">Load Local .tar.gz</button>
                <input type="file" id="torrentFileInput" accept=".torrent" style="display: none;" onchange="handleTorrentFile(this.files[0])">
                <input type="file" id="localFileInput" accept=".tar.gz,.tar" style="display: none;" onchange="loadLocalFile()">
            </div>
        </div>
    </details>

    <div style="margin-bottom: 1rem;">
        <input type="text" id="searchBox" placeholder="Search books by title or author..."
            style="width: 100%; padding: 0.75rem; border: 2px solid #e0e0e0; border-radius: 0.5rem; font-size: 0.95rem;">
    </div>

    <div class="book-list" id="bookList" style="max-height: 500px;"></div>
    <div style="margin-top: 0.5rem; text-align: center; color: #999; font-size: 0.85rem;" id="bookListHint">
        <span id="totalBooks">0</span> books available
    </div>

    <details style="margin-top: 1rem;">
        <summary style="cursor: pointer; padding: 0.5rem; background: rgba(255,255,255,0.8); border-radius: 0.25rem; font-size: 0.85rem; color: #999;">
            üìä Catalog Metadata
        </summary>
        <div id="catalogMetadata" style="margin-top: 0.5rem; padding: 0.75rem; background: #f8f8f8; border-radius: 0.25rem; font-size: 0.8rem; font-family: monospace;">
            <div style="color: #999;">Loading...</div>
        </div>
    </details>

    <details style="margin-top: 1rem;">
        <summary style="cursor: pointer; padding: 0.5rem; background: rgba(255,255,255,0.8); border-radius: 0.25rem; font-size: 0.85rem; color: #999;">
            üìù Console Log
        </summary>
        <div id="log" style="margin-top: 0.5rem; padding: 0.75rem; background: #f8f8f8; border-radius: 0.25rem; font-size: 0.8rem; max-height: 200px; overflow-y: auto;"></div>
    </details>

    <script>
        const client = new WebTorrent();
        let currentTorrent = null;
        let loadedTorrentFile = null;
        let localArchiveFile = null;
        let catalogBooks = []; // Store parsed catalog books

        // Default magnet link for tar.gz
        const DEFAULT_MAGNET = 'magnet:?xt=urn:btih:a7bb7a777b775c6f7205e90b57c44b014a4e5f0c&dn=gutenberg-txt-files.tar.gz&tr=wss%3A%2F%2Ftracker.openwebtorrent.com&tr=wss%3A%2F%2Ftracker.btorrent.xyz&tr=wss%3A%2F%2Ftracker.webtorrent.dev';

        console.log('%cüìö POC11 - Progressive Library Builder', 'background: #667eea; color: white; font-size: 14px; font-weight: bold; padding: 4px 8px; border-radius: 4px;');

        // Simple string hash function (cyrb53)
        function hashString(str) {
            let h1 = 0xdeadbeef, h2 = 0x41c6ce57;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
            const hash = 4294967296 * (2097151 & h2) + (h1 >>> 0);
            // Convert to 40-char hex string (like InfoHash)
            return hash.toString(16).padStart(16, '0').repeat(3).substring(0, 40);
        }

        // Load saved background color and catalog on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Set background from hash of our own source code (static parts only)
            // Hash the script content which doesn't change at runtime
            const scripts = Array.from(document.getElementsByTagName('script'))
                .map(s => s.textContent)
                .join('');
            const sourceHash = hashString(scripts);
            setBackgroundFromHash(sourceHash);
            console.log(`üé® Color seed from source hash: ${sourceHash}`);

            loadCatalog(); // Auto-load catalog
        });

        function hashToColor(hash) {
            // Convert InfoHash to two colors for gradient
            if (!hash || hash.length < 40) {
                return null;
            }

            // Use first 6 chars for color1, chars 20-26 for color2
            const color1 = '#' + hash.substring(0, 6);
            const color2 = '#' + hash.substring(20, 26);

            return { color1, color2 };
        }

        function setBackgroundFromHash(hash) {
            const colors = hashToColor(hash);
            if (!colors) return;

            const gradient = `linear-gradient(135deg, ${colors.color1} 0%, ${colors.color2} 100%)`;
            document.body.style.background = gradient;

            // Save to localStorage
            localStorage.setItem('poc11_bg_color', JSON.stringify(colors));

            log(`üé® Background: ${colors.color1} ‚Üí ${colors.color2}`);
        }

        function loadBackgroundColor() {
            const saved = localStorage.getItem('poc11_bg_color');
            if (!saved) return;

            const colors = JSON.parse(saved);
            const gradient = `linear-gradient(135deg, ${colors.color1} 0%, ${colors.color2} 100%)`;
            document.body.style.background = gradient;

            console.log(`üé® Loaded background color: ${colors.color1} ‚Üí ${colors.color2}`);
        }

        async function loadCatalog() {
            updateStatus('üìö Loading catalog...');

            try {
                const response = await fetch('GUTINDEX.ALL.new');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const text = await response.text();
                catalogBooks = GutIndexParser.parseIndex(text);

                // Extract and display metadata
                const fileSize = text.length;
                const lastModified = response.headers.get('Last-Modified') || 'Unknown';
                const contentType = response.headers.get('Content-Type') || 'text/plain';

                // Calculate a simple hash for verification
                const catalogHash = hashString(text).substring(0, 8);

                updateStatus(`‚úÖ ${catalogBooks.length.toLocaleString()} books available`);
                showLibrary();
                displayCatalogMetadata({
                    books: catalogBooks.length,
                    fileSize: fileSize,
                    lastModified: lastModified,
                    contentType: contentType,
                    hash: catalogHash,
                    source: 'GUTINDEX.ALL.new'
                });

            } catch (error) {
                updateStatus(`‚ùå Error loading catalog: ${error.message}`);
                console.error('Catalog load error:', error);
            }
        }

        function displayCatalogMetadata(meta) {
            const metadataDiv = document.getElementById('catalogMetadata');
            metadataDiv.innerHTML = `
                <div style="margin-bottom: 0.5rem;"><strong>üìÅ Source:</strong> ${meta.source}</div>
                <div style="margin-bottom: 0.5rem;"><strong>üìö Books:</strong> ${meta.books.toLocaleString()}</div>
                <div style="margin-bottom: 0.5rem;"><strong>üíæ File Size:</strong> ${formatBytes(meta.fileSize)}</div>
                <div style="margin-bottom: 0.5rem;"><strong>üìÖ Last Modified:</strong> ${meta.lastModified}</div>
                <div style="margin-bottom: 0.5rem;"><strong>üìù Content Type:</strong> ${meta.contentType}</div>
                <div><strong>üîê Hash (first 8):</strong> ${meta.hash}</div>
            `;
            log(`üìä Catalog metadata: ${meta.books.toLocaleString()} books, ${formatBytes(meta.fileSize)}, hash: ${meta.hash}`);
        }

        function updateStatus(message) {
            document.getElementById('statusLine').textContent = message;
        }

        function handleTorrentFile(file) {
            if (!file) return;
            log(`üî• Loading .torrent file: ${file.name}`);

            const reader = new FileReader();
            reader.onload = (e) => {
                loadedTorrentFile = new Uint8Array(e.target.result);

                // Parse torrent to get magnet link
                client.add(loadedTorrentFile, { path: '/temp' }, (torrent) => {
                    const magnetLink = torrent.magnetURI;
                    const infoHash = torrent.infoHash;

                    log(`‚úÖ Torrent file loaded: ${file.name}`);
                    log(`üîó InfoHash: ${infoHash}`);
                    log(`üìã Magnet link: ${magnetLink.substring(0, 100)}...`);

                    // Show magnet link in input (read-only)
                    document.getElementById('magnetInput').value = magnetLink;
                    document.getElementById('magnetInput').style.fontSize = '0.75rem';

                    // Set background color from InfoHash
                    setBackgroundFromHash(infoHash);

                    // Destroy temp torrent (we'll re-add with actual download)
                    torrent.destroy();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function loadLocalFile() {
            const fileInput = document.getElementById('localFileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file first');
                return;
            }

            localArchiveFile = file;
            log(`üìÅ Loading local file: ${file.name} (${formatBytes(file.size)})`);
            log(`üîì Starting extraction...`);

            // Skip download, go straight to extraction
            processLocalArchive(file);
        }

        function log(message) {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(message);
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatTime(seconds) {
            if (seconds === Infinity) return '‚àû';
            if (isNaN(seconds)) return 'N/A';
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        let pieceMapInitialized = false;
        function updatePieceMap(pieces) {
            const pieceMap = document.getElementById('pieceMap');
            const totalPieces = pieces.length;

            // Group into chunks of ~26 pieces each (1301/50 = 26)
            const numBlocks = 50;
            const piecesPerBlock = Math.ceil(totalPieces / numBlocks);

            // Initialize on first call
            if (!pieceMapInitialized) {
                pieceMapInitialized = true;
                pieceMap.innerHTML = '';

                for (let i = 0; i < numBlocks; i++) {
                    const block = document.createElement('div');
                    block.style.cssText = 'width: 16px; height: 16px; background: #e0e0e0; border-radius: 2px;';
                    block.dataset.index = i;
                    pieceMap.appendChild(block);
                }
            }

            // Update colors based on completion of each group
            const children = pieceMap.children;
            for (let i = 0; i < children.length; i++) {
                const startPiece = i * piecesPerBlock;
                const endPiece = Math.min(startPiece + piecesPerBlock, totalPieces);

                // Check how many pieces in this group are complete
                let complete = 0;
                for (let j = startPiece; j < endPiece; j++) {
                    if (pieces[j]) complete++;
                }

                const percentComplete = complete / (endPiece - startPiece);

                // Color based on completion: green if 100%, yellow if partial, gray if 0%
                if (percentComplete === 1) {
                    children[i].style.background = '#4caf50';
                } else if (percentComplete > 0) {
                    children[i].style.background = '#ffa726';
                } else {
                    children[i].style.background = '#e0e0e0';
                }

                children[i].title = `Block ${i + 1}: ${(percentComplete * 100).toFixed(0)}% complete`;
            }
        }

        function startDownload() {
            // Get magnet link from input or use default
            const magnetInput = document.getElementById('magnetInput').value.trim();
            const magnetLink = loadedTorrentFile ? loadedTorrentFile : (magnetInput || DEFAULT_MAGNET);

            if (loadedTorrentFile) {
                log('üì• Starting WebTorrent download with .torrent file...');
            } else {
                log('üì• Starting WebTorrent download...');
                log(`üîó Magnet: ${magnetLink.substring(0, 80)}...`);
            }

            currentTorrent = client.add(magnetLink, {
                path: '/downloads'
            });

            currentTorrent.on('metadata', () => {
                log(`‚úÖ Got torrent metadata`);
                log(`üìä Total size: ${formatBytes(currentTorrent.length)}`);
                log(`üìÅ Files: ${currentTorrent.files.length}`);
                log(`üß© Pieces: ${currentTorrent.pieces.length} (${formatBytes(currentTorrent.pieceLength)} each)`);

                // Set background color from InfoHash
                setBackgroundFromHash(currentTorrent.infoHash);
            });

            currentTorrent.on('wire', (wire, addr) => {
                log(`üîó Connected to peer: ${addr}`);
            });

            setInterval(() => {
                if (!currentTorrent) return;

                const speed = formatBytes(currentTorrent.downloadSpeed);
                const peers = currentTorrent.numPeers;

                // Calculate progress from pieces (more accurate than currentTorrent.progress)
                const pieces = currentTorrent.pieces ? currentTorrent.pieces.filter(p => p).length : 0;
                const totalPieces = currentTorrent.pieces ? currentTorrent.pieces.length : 0;
                const progress = totalPieces > 0 ? Math.round((pieces / totalPieces) * 100) : 0;

                let statusMsg = '';
                if (progress === 0 && peers === 0) {
                    statusMsg = 'üîç Searching for peers...';
                } else if (progress < 100) {
                    statusMsg = `‚¨áÔ∏è ${progress}% (${pieces}/${totalPieces} pieces) ‚Ä¢ ${speed}/s ‚Ä¢ ${peers} peer${peers !== 1 ? 's' : ''}`;
                } else {
                    statusMsg = `‚úÖ Complete! Seeding to ${peers} peer${peers !== 1 ? 's' : ''}`;
                }
                updateStatus(statusMsg);
            }, 1000);

            currentTorrent.on('done', () => {
                updateStatus(`‚úÖ Download complete! ${catalogBooks.length.toLocaleString()} books available`);
            });

            currentTorrent.on('error', (err) => {
                log(`‚ùå Error: ${err.message}`);
                console.error('Torrent error:', err);
            });
        }

        function processLocalArchive(file) {
            updateStatus(`‚úÖ Local file loaded: ${file.name}`);
            showLibrary();
        }

        function showLibrary() {
            const totalBooks = catalogBooks.length;
            document.getElementById('totalBooks').textContent = totalBooks.toLocaleString();

            const searchBox = document.getElementById('searchBox');
            const bookList = document.getElementById('bookList');
            const bookListHint = document.getElementById('bookListHint');

            // Show first 50 books by default
            displayBooks(catalogBooks.slice(0, 50));

            // Setup search (only once)
            if (!searchBox.dataset.initialized) {
                searchBox.dataset.initialized = 'true';
                let searchTimeout;
                searchBox.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        const query = e.target.value.trim().toLowerCase();

                        if (query.length === 0) {
                            displayBooks(catalogBooks.slice(0, 50));
                            return;
                        }

                        if (query.length < 2) {
                            bookList.innerHTML = '';
                            return;
                        }

                        // Search books
                        const results = catalogBooks.filter(book =>
                            book.title.toLowerCase().includes(query) ||
                            book.author.toLowerCase().includes(query)
                        ).slice(0, 100);

                        displayBooks(results);
                    }, 300);
                });
            }
        }

        function displayBooks(books) {
            const bookList = document.getElementById('bookList');
            bookList.innerHTML = '';

            books.forEach(book => {
                const bookItem = document.createElement('div');
                bookItem.className = 'book-item';

                const titleSpan = document.createElement('span');
                titleSpan.className = 'book-title';
                titleSpan.textContent = `${book.title} ‚Äî ${book.author}`;

                const openBtn = document.createElement('button');
                openBtn.className = 'book-btn';
                openBtn.textContent = 'üìñ';
                openBtn.title = 'Open book';
                openBtn.onclick = () => {
                    if (currentTorrent || localArchiveFile) {
                        openBookFromTorrent(book);
                    } else {
                        alert('Please start downloading or load a local file first!');
                    }
                };

                bookItem.appendChild(titleSpan);
                bookItem.appendChild(openBtn);
                bookList.appendChild(bookItem);
            });
        }

        async function openBookFromTorrent(book) {
            log(`üìñ Opening "${book.title}"...`);

            try {
                let arrayBuffer;
                let progress = 0;

                // Check if we're using local file or torrent
                if (localArchiveFile) {
                    log(`üìÅ Reading from local file: ${localArchiveFile.name}`);
                    arrayBuffer = await localArchiveFile.arrayBuffer();
                    progress = 100;
                } else if (currentTorrent && currentTorrent.files && currentTorrent.files.length > 0) {
                    // Get the .tar.gz file from WebTorrent
                    const file = currentTorrent.files[0];
                    progress = (file.progress * 100).toFixed(1);
                    log(`üì¶ Archive progress: ${progress}% (${formatBytes(file.downloaded)} / ${formatBytes(file.length)})`);

                    // Select this file with high priority to download needed pieces
                    file.select(0); // Highest priority

                    log(`üîç Reading from downloaded blocks...`);

                    // Try to get available data using streaming
                    const stream = file.createReadStream();
                    const chunks = [];
                    let totalBytes = 0;
                    const maxBytes = 500 * 1024 * 1024; // Read up to 500MB for extraction attempt

                    // Read available data
                    for await (const chunk of stream) {
                        chunks.push(chunk);
                        totalBytes += chunk.length;

                        if (totalBytes >= maxBytes || totalBytes >= file.downloaded) {
                            break;
                        }
                    }

                    log(`üì• Read ${formatBytes(totalBytes)} from available blocks`);

                    // Combine chunks
                    const combinedBuffer = new Uint8Array(totalBytes);
                    let offset = 0;
                    for (const chunk of chunks) {
                        combinedBuffer.set(chunk, offset);
                        offset += chunk.length;
                    }

                    arrayBuffer = combinedBuffer.buffer;
                } else {
                    throw new Error('No archive available');
                }

                log(`üîì Decompressing with gzip...`);
                let decompressed;
                try {
                    decompressed = pako.ungzip(new Uint8Array(arrayBuffer));
                } catch (e) {
                    // If gzip fails, try partial decompression
                    log(`‚ö†Ô∏è Partial gzip data, attempting extraction...`);
                    decompressed = pako.inflate(new Uint8Array(arrayBuffer), { raw: true });
                }

                log(`üìÇ Extracting books from tar archive...`);

                // Look for the book file - try common patterns
                const bookFileName = `pg${book.etextNo}.txt`;
                const possiblePaths = [
                    `cache/epub/${book.etextNo}/${bookFileName}`,
                    `${book.etextNo}/${bookFileName}`,
                    bookFileName
                ];

                log(`üîç Looking for: ${possiblePaths[0]}`);

                // Use js-untar to extract
                const files = await untar(decompressed.buffer);

                // Find the book file
                let bookFile = null;
                for (const path of possiblePaths) {
                    bookFile = files.find(f => f.name === path || f.name.endsWith(path));
                    if (bookFile) break;
                }

                if (!bookFile) {
                    // Try fuzzy match
                    bookFile = files.find(f => f.name.includes(`${book.etextNo}`) && f.name.endsWith('.txt'));
                }

                if (!bookFile) {
                    throw new Error(`Book not yet available in downloaded blocks. Try again as more downloads (currently ${progress}%)`);
                }

                log(`‚úÖ Found: ${bookFile.name}`);

                // Read the text content
                const textContent = new TextDecoder('utf-8').decode(bookFile.buffer);

                // Display the book
                displayBook(book, textContent);

            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                console.error('Book opening error:', error);
                const downloadPct = (currentTorrent && currentTorrent.files && currentTorrent.files[0])
                    ? (currentTorrent.files[0].progress * 100).toFixed(1)
                    : '0';
                alert(`Could not extract book from available blocks (${downloadPct}% downloaded)\n\n${error.message}\n\nTry again as more data downloads, or wait until download is complete.`);
            }
        }

        function displayBook(book, content) {
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:#fff;z-index:1000;overflow-y:auto;padding:1rem';
            overlay.innerHTML = `<div style="max-width:700px;margin:0 auto;font-family:Georgia,serif;line-height:1.5">
<a href="#" onclick="this.parentElement.parentElement.remove();return false" style="font-size:1.5rem;text-decoration:none;color:#999">√ó</a>
<h3 style="margin:0.5rem 0">${book.title}</h3>
<small style="color:#666">${book.author}</small>
<hr style="margin:1rem 0;border:none;border-top:1px solid #ddd">
<pre style="white-space:pre-wrap;font-family:Georgia,serif;font-size:0.95rem">${content}</pre>
</div>`;
            document.body.appendChild(overlay);
            log(`‚úÖ Displaying "${book.title}"`);
        }

        log('‚úÖ Ready to download Gutenberg collection');
        log('üí° Click "Start Download" to begin');
    </script>
</body>
</html>
