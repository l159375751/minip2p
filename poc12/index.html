<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POC12 - Block Diagnostics Lab</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìö</text></svg>">
    <script src="vendor/webtorrent.min.js"></script>
    <script src="library-builder.js"></script>
    <script src="vendor/pako.min.js"></script>
    <script src="vendor/untar.js"></script>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border-left: 4px solid rgba(102, 126, 234, 0.5);
        }
        h1 {
            color: white;
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }
        .progress-container {
            background: #e8e8e8;
            border-radius: 0.25rem;
            height: 24px;
            overflow: hidden;
            margin: 0.75rem 0;
        }
        .progress-bar {
            background: #667eea;
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 500;
            font-size: 0.85rem;
        }
        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin: 1rem 0;
            padding: 0.75rem 0;
            border-top: 1px solid #e0e0e0;
            border-bottom: 1px solid #e0e0e0;
        }
        .stat {
            flex: 0 0 auto;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }
        .stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #333;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.25rem;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            width: 100%;
            transition: background 0.2s;
        }
        button:hover {
            background: #5568d3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .log {
            background: #f8f8f8;
            color: #333;
            padding: 0.75rem;
            border-radius: 0.25rem;
            max-height: 250px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.8rem;
            border: 1px solid #e0e0e0;
        }
        .log > div {
            padding: 0.25rem 0;
            border-bottom: 1px dotted #e0e0e0;
        }
        .log > div:last-child {
            border-bottom: none;
        }
        .book-list {
            background: white;
            border: 1px solid #ddd;
            font-size: 0.8rem;
            max-height: 500px;
            overflow-y: auto;
        }
        .book-item {
            display: grid;
            grid-template-columns: 1fr 2fr 40px;
            gap: 1rem;
            padding: 0.4rem 0.6rem;
            border-bottom: 1px solid #eee;
            align-items: center;
        }
        .book-item:hover {
            background: #f5f5f5;
        }
        .book-item a {
            color: #667eea;
            text-decoration: none;
            font-size: 1.2rem;
        }
        .book-item a:hover {
            opacity: 0.7;
        }
        .book-item a.disabled {
            color: #bbb;
            cursor: not-allowed;
        }
        .book-item a.disabled:hover {
            opacity: 1;
        }
        .download-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #4a4a4a;
            margin-bottom: 0.5rem;
        }
        .download-status {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: 0.75rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .download-metrics {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .download-metrics .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f3f4ff;
            border-radius: 0.4rem;
            padding: 0.4rem 0.75rem;
        }
        .metric-label {
            font-size: 0.7rem;
            letter-spacing: 0.4px;
            text-transform: uppercase;
            color: #6b6b6b;
        }
        .metric-value {
            font-weight: 600;
            color: #323c88;
            font-size: 0.95rem;
        }
        .download-meta {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: #555;
        }
        .download-meta code {
            display: block;
            padding: 0.35rem 0.5rem;
            background: #f8f8ff;
            border-radius: 0.35rem;
            word-break: break-all;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .meta-row {
            display: grid;
            gap: 0.25rem;
        }
        .meta-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: #8a8a8a;
        }
        .piece-map-container {
            margin-top: 0.75rem;
        }
        .piece-map-label {
            font-size: 0.75rem;
            letter-spacing: 0.4px;
            text-transform: uppercase;
            color: #8a8a8a;
            margin-bottom: 0.35rem;
        }
        .piece-summary {
            font-size: 0.75rem;
            color: #555;
            margin-bottom: 0.35rem;
        }
        .piece-map {
            display: grid;
            grid-template-columns: repeat(40, 1fr);
            gap: 2px;
        }
        .piece-map div {
            width: 100%;
            padding-bottom: 100%;
            border-radius: 1px;
            background: #e0e0e0;
        }
        .piece-details {
            font-size: 0.75rem;
            color: #555;
            margin-top: 0.5rem;
            display: grid;
            gap: 0.25rem;
        }
    </style>
</head>
<body>
    <h1>üìö POC12 ‚Äì Block Diagnostics Lab</h1>

    <div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.9); border-radius: 0.5rem; border-left: 4px solid rgba(102, 126, 234, 0.5);">
        <div id="statusLine" style="font-size: 0.9rem; color: #666;">
            üìö Loading catalog...
        </div>
        <div id="infoHashLine" style="font-size: 0.8rem; color: #888; margin-top: 0.25rem; word-break: break-all;">
            InfoHash: ‚Äî
        </div>
    </div>

    <div class="card" id="downloadCard" style="min-height: 220px; display: flex; flex-direction: column;">
        <div class="download-card-header">
            <span>‚¨áÔ∏è Downloads</span>
        </div>
        <div id="downloadStatusLine" class="download-status" style="min-height: 1.2rem;">No active downloads yet.</div>
        <div class="download-metrics" style="flex: 0 0 auto;">
            <div class="metric">
                <div class="metric-label">Archive</div>
                <div class="metric-value" id="downloadArchive">‚Äî</div>
            </div>
            <div class="metric">
                <div class="metric-label">Speed</div>
                <div class="metric-value" id="downloadSpeed">‚Äî</div>
            </div>
            <div class="metric">
                <div class="metric-label">Peers</div>
                <div class="metric-value" id="downloadPeers">‚Äî</div>
            </div>
            <div class="metric">
                <div class="metric-label">Uploaded</div>
                <div class="metric-value" id="downloadUpload">‚Äî</div>
            </div>
            <div class="metric">
                <div class="metric-label">Total</div>
                <div class="metric-value" id="downloadTotalSize">‚Äî</div>
            </div>
        </div>
        <div class="download-meta" style="flex: 0 0 auto;">
            <div class="meta-row">
                <span class="meta-label">InfoHash</span>
                <code id="downloadInfoHash">‚Äî</code>
            </div>
            <div class="meta-row">
                <span class="meta-label">Magnet</span>
                <code id="downloadMagnet">‚Äî</code>
            </div>
        </div>

        <!-- Merged Torrent Metadata section -->
        <div id="torrentMetadataSection" style="flex: 0 0 auto; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e0e0e0; display: none;">
            <div style="font-weight: 600; margin-bottom: 0.35rem; font-size: 0.85rem; color: #4a4a4a;">üß© Torrent Metadata</div>
            <div id="torrentMetaSummary" style="margin-bottom: 0.35rem; color: #555; font-size: 0.8rem;">Awaiting metadata‚Ä¶</div>
            <div id="torrentMetaPieces" style="margin-bottom: 0.5rem; color: #555; font-size: 0.75rem;"></div>
            <div id="torrentMetaFiles" style="padding: 0.5rem; background: #f8f8ff; border-radius: 0.25rem; font-size: 0.75rem; max-height: 150px; overflow-y: auto;"></div>
        </div>

        <div id="pieceMapContainer" class="piece-map-container" style="display:none; flex: 1 1 auto;">
            <div class="piece-map-label">Pieces</div>
            <div id="pieceSummary" class="piece-summary">Waiting for data‚Ä¶</div>
            <div id="pieceMap" class="piece-map"></div>
            <div id="pieceDetails" class="piece-details"></div>
            <div id="blockStrip" class="block-strip"></div>
        </div>
    </div>

    <div class="card" style="padding: 1.25rem; margin-bottom: 1rem;">
        <h2 style="margin: 0 0 0.75rem 0; font-size: 1.05rem; color: #4a4a4a;">‚öôÔ∏è Download from Network</h2>
        <input type="text" id="magnetInput" placeholder="magnet:?xt=urn:btih:..." value="magnet:?xt=urn:btih:a7bb7a777b775c6f7205e90b57c44b014a4e5f0c&dn=gutenberg-txt-files.tar.gz&tr=wss%3A%2F%2Ftracker.openwebtorrent.com&tr=wss%3A%2F%2Ftracker.btorrent.xyz&tr=wss%3A%2F%2Ftracker.webtorrent.dev"
            style="width: 100%; padding: 0.65rem; border: 1px solid #ddd; border-radius: 0.35rem; font-family: monospace; font-size: 0.85rem; margin-bottom: 0.75rem;">
        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem;">
            <button type="button" onclick="applyMagnetPreset('full')" style="flex: 1; min-width: 180px; background: #5c6bc0;">
                üß≤ Full Gutenberg (10GB)
            </button>
            <button type="button" onclick="applyMagnetPreset('mini')" style="flex: 1; min-width: 180px; background: #009688;">
                ‚ö° Mini Sample (10MB)
            </button>
        </div>
        <div style="display: flex; gap: 0.5rem;">
            <button onclick="startDownload()" style="flex: 1;">üöÄ Start Download</button>
            <button onclick="document.getElementById('torrentFileInput').click()" style="flex: 0.8;">üìÑ or .torrent</button>
            <input type="file" id="torrentFileInput" accept=".torrent" style="display: none;" onchange="handleTorrentFile(this.files[0])">
        </div>
    </div>

    <div class="card" style="padding: 1.25rem; margin-bottom: 1rem; background: rgba(76, 175, 80, 0.08);">
        <h2 style="margin: 0 0 0.5rem 0; font-size: 1.05rem; color: #2e7d32;">üìÇ Local Files & Seeding</h2>
        <p style="margin: 0 0 0.75rem 0; font-size: 0.85rem; color: #555;">
            Load a local .tar.gz to view instantly, or load both files to seed to the network.
        </p>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.75rem;">
            <button onclick="document.getElementById('localFileInput').click()" style="flex: 1; background: #43a047;">
                üì¶ Load .tar.gz File
            </button>
            <button onclick="document.getElementById('seedTorrentInput').click()" style="flex: 0.8; background: #43a047;">
                üìÑ + .torrent
            </button>
            <input type="file" id="localFileInput" accept=".tar.gz,.tar" style="display: none;" onchange="loadLocalFile()">
            <input type="file" id="seedTorrentInput" accept=".torrent" style="display: none;" onchange="handleSeedTorrentFile(this.files[0])">
        </div>

        <!-- Seeding status (only shown when both files loaded) -->
        <div id="seedingStatusPanel" style="display: none; margin-bottom: 0.75rem;">
            <div style="margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(255,255,255,0.7); border-radius: 0.25rem; font-size: 0.8rem;">
                <div style="margin-bottom: 0.35rem;">
                    <strong>Content:</strong> <span id="seedContentStatus" style="color: #999;">Not loaded</span>
                </div>
                <div>
                    <strong>Torrent:</strong> <span id="seedTorrentStatus" style="color: #999;">Not loaded</span>
                </div>
            </div>
            <div id="seedDebugPanel" style="display: none; margin-bottom: 0.75rem; padding: 0.75rem; background: #f8f8f8; border-radius: 0.25rem; font-family: monospace; font-size: 0.75rem; max-height: 300px; overflow-y: auto;">
                <div style="font-weight: 600; margin-bottom: 0.5rem; color: #2e7d32;">üî¨ Torrent Metadata:</div>
                <div id="seedDebugContent"></div>
            </div>
            <button id="startSeedingBtn" onclick="startSeeding()" style="background: #2e7d32; width: 100%;" disabled>
                üöÄ Start Seeding
            </button>
        </div>
    </div>

    <div style="margin-bottom: 1rem;">
        <input type="text" id="searchBox" placeholder="Search books by title or author..."
            style="width: 100%; padding: 0.75rem; border: 2px solid #e0e0e0; border-radius: 0.5rem; font-size: 0.95rem;">
    </div>

    <div class="book-list" id="bookList" style="max-height: 500px;"></div>

    <div class="card" style="padding: 1.25rem; margin-top: 1rem;">
        <h2 style="margin: 0 0 0.5rem 0; font-size: 1.05rem; color: #4a4a4a;">üìä Catalog & Browser Storage</h2>
        <div id="catalogMetadata" style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f8f8f8; border-radius: 0.25rem; font-size: 0.8rem; font-family: monospace;">
            <div style="color: #999;">Loading...</div>
        </div>
        <div id="catalogSummary" style="margin-bottom: 0.75rem; color: #555; font-size: 0.8rem;">üìö Loading catalog‚Ä¶</div>
        <div id="browserFilesystem" style="padding: 0.75rem; background: #f8f8f8; border-radius: 0.25rem; font-size: 0.8rem; font-family: monospace; max-height: 300px; overflow-y: auto;"></div>
        <div id="downloadedFiles" style="margin-top: 0.75rem; padding: 0.75rem; background: #f0f7ff; border-radius: 0.25rem; font-size: 0.8rem; font-family: monospace; max-height: 200px; overflow-y: auto; display:none;"></div>
    </div>

    <div class="card" style="padding: 1.25rem; margin-top: 1rem;">
        <h2 style="margin: 0 0 0.5rem 0; font-size: 1.05rem; color: #4a4a4a;">üìù Console Log</h2>
        <div id="log" style="padding: 0.75rem; background: #f8f8f8; border-radius: 0.25rem; font-size: 0.8rem; max-height: 200px; overflow-y: auto;"></div>
    </div>

    <script src="vendor/webtorrent.min.js"></script>

    <script>
        // Bencode parser for .torrent files
        // NOTE: Using custom parser because WebTorrent's client.add(buffer) was throwing
        // "Invalid torrent identifier" errors. WebTorrent SHOULD have parse-torrent built-in,
        // but it may not be exposed in the browser bundle. Check console logs below.
        function parseBencode(buffer, offset = 0) {
            const view = new Uint8Array(buffer);
            let pos = offset;

            function readUntil(delimiter) {
                const start = pos;
                while (pos < view.length && view[pos] !== delimiter) pos++;
                return view.slice(start, pos);
            }

            function decode() {
                const ch = String.fromCharCode(view[pos]);

                // Integer: i<number>e
                if (ch === 'i') {
                    pos++; // skip 'i'
                    const numBytes = readUntil(101); // 'e' = 101
                    pos++; // skip 'e'
                    const numStr = new TextDecoder().decode(numBytes);
                    return parseInt(numStr, 10);
                }

                // List: l<items>e
                if (ch === 'l') {
                    pos++; // skip 'l'
                    const list = [];
                    while (view[pos] !== 101) { // 'e' = 101
                        list.push(decode());
                    }
                    pos++; // skip 'e'
                    return list;
                }

                // Dictionary: d<key><value>...e
                if (ch === 'd') {
                    pos++; // skip 'd'
                    const dict = {};
                    while (view[pos] !== 101) { // 'e' = 101
                        const key = decode();
                        const value = decode();
                        dict[key] = value;
                    }
                    pos++; // skip 'e'
                    return dict;
                }

                // String: <length>:<string>
                if (ch >= '0' && ch <= '9') {
                    const lenBytes = readUntil(58); // ':' = 58
                    pos++; // skip ':'
                    const len = parseInt(new TextDecoder().decode(lenBytes), 10);
                    const str = view.slice(pos, pos + len);
                    pos += len;
                    // Try to decode as UTF-8 text, fallback to raw bytes
                    try {
                        return new TextDecoder().decode(str);
                    } catch {
                        return str;
                    }
                }

                throw new Error(`Invalid bencode at position ${pos}: ${ch}`);
            }

            const result = decode();
            return { value: result, endOffset: pos };
        }

        // Calculate InfoHash from .torrent file
        async function calculateInfoHash(torrentBuffer) {
            const parsed = parseBencode(torrentBuffer);
            const torrent = parsed.value;

            if (!torrent || !torrent.info) {
                throw new Error('Invalid torrent: missing info dictionary');
            }

            // Find the raw bytes of the "info" dictionary
            // We need to bencode it again to get the exact bytes for hashing
            const torrentArray = new Uint8Array(torrentBuffer);

            // Find "4:info" in the buffer (bencode for the key "info")
            const infoKeyBytes = new Uint8Array([52, 58, 105, 110, 102, 111]); // "4:info"
            let infoStart = -1;
            for (let i = 0; i < torrentArray.length - 6; i++) {
                let match = true;
                for (let j = 0; j < 6; j++) {
                    if (torrentArray[i + j] !== infoKeyBytes[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    infoStart = i + 6; // Start after "4:info"
                    break;
                }
            }

            if (infoStart === -1) {
                throw new Error('Could not find info dictionary in torrent file');
            }

            // Parse from infoStart to get the info dictionary bytes
            const infoResult = parseBencode(torrentBuffer, infoStart);
            const infoBytes = torrentArray.slice(infoStart, infoResult.endOffset);

            // Calculate SHA-1 hash
            const hashBuffer = await crypto.subtle.digest('SHA-1', infoBytes);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const infoHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            return {
                infoHash,
                name: torrent.info.name || 'unknown',
                announce: torrent.announce || '',
                announceList: torrent['announce-list'] || [],
                comment: torrent.comment || '',
                createdBy: torrent['created by'] || '',
                creationDate: torrent['creation date'] || 0
            };
        }

        // Create magnet link from torrent metadata
        function createMagnetLink(metadata) {
            let magnet = `magnet:?xt=urn:btih:${metadata.infoHash}`;

            if (metadata.name) {
                magnet += `&dn=${encodeURIComponent(metadata.name)}`;
            }

            // Add trackers
            const trackers = [];
            if (metadata.announce) {
                trackers.push(metadata.announce);
            }
            if (metadata.announceList && metadata.announceList.length > 0) {
                metadata.announceList.forEach(tierOrTracker => {
                    if (Array.isArray(tierOrTracker)) {
                        tierOrTracker.forEach(t => trackers.push(t));
                    } else {
                        trackers.push(tierOrTracker);
                    }
                });
            }

            // Deduplicate and add trackers
            const uniqueTrackers = [...new Set(trackers)];
            uniqueTrackers.forEach(tracker => {
                magnet += `&tr=${encodeURIComponent(tracker)}`;
            });

            return magnet;
        }

        // Optimized WebTorrent client for faster downloads
        const MAX_TORRENT_CONNECTIONS = 80;
        let client = null;
        if (window.WebTorrent) {
            client = new WebTorrent({
                maxConns: MAX_TORRENT_CONNECTIONS, // Higher than default, but below leak warning threshold
                dht: true,            // Enable DHT for peer discovery
                webSeeds: true        // Enable web seeds if available
            });

            // Check if WebTorrent exposes parseTorrent
            console.log('üîç Checking WebTorrent capabilities:');
            console.log('  - WebTorrent:', typeof window.WebTorrent);
            console.log('  - parseTorrent:', typeof window.WebTorrent.parseTorrent);
            console.log('  - Available:', Object.keys(window.WebTorrent).filter(k => k.toLowerCase().includes('parse')));
        } else {
            console.warn('WebTorrent not available in this environment.');
        }
        let currentTorrent = null;
        let torrentStatsInterval = null;
        let loadedMagnetLink = null; // Store magnet link from .torrent file
        let localArchiveFile = null;

        // Seeding state
        let seedTorrentFile = null;      // Loaded .torrent file for seeding
        let seedContentFile = null;      // Loaded content file for seeding
        let seedTorrentMetadata = null;  // Parsed torrent metadata

        let catalogBooks = []; // Store parsed catalog books
        let catalogIndexByEtext = new Map();
        let currentDisplayedBooks = [];
        const tarTextDecoder = new TextDecoder('utf-8');
        let progressiveExtraction = null;
        let cachedBookCount = 0;
        const MAX_PROGRESSIVE_BYTES = 512 * 1024 * 1024; // Safety cap for streaming extraction
        const MAX_CACHED_BOOKS = 25; // Limit in-memory prefetched books
        let currentInfoHash = null;
        let catalogSummary = {
            status: 'üìö Loading catalog‚Ä¶',
            infoHash: null
        };
        let activeDownload = { magnet: null };
        let hasStartedDownload = false;
        const seenTorrentWarnings = new Set();
        const FALLBACK_TRACKERS = [
            'wss://tracker.openwebtorrent.com',
            'wss://tracker.webtorrent.dev',
            'wss://tracker.btorrent.xyz',
            'wss://tracker.fastcast.nz',
            'wss://tracker.files.fm:7073/announce'
        ];

        // Default magnet link with MANY trackers for better peer discovery
        const DEFAULT_MAGNET = 'magnet:?xt=urn:btih:a7bb7a777b775c6f7205e90b57c44b014a4e5f0c&dn=gutenberg-txt-files.tar.gz' +
            '&tr=wss%3A%2F%2Ftracker.openwebtorrent.com' +
            '&tr=wss%3A%2F%2Ftracker.webtorrent.dev' +
            '&tr=wss%3A%2F%2Ftracker.btorrent.xyz' +
            '&tr=wss%3A%2F%2Ftracker.fastcast.nz' +
            '&tr=wss%3A%2F%2Ftracker.files.fm%3A7073%2Fannounce' +
            '&tr=wss%3A%2F%2Fspacetradersapi-chatbox.herokuapp.com%3A443%2Fannounce' +
            '&tr=ws%3A%2F%2Ftracker.webtorrent.io';
        const MINI_ARCHIVE_MAGNET = 'magnet:?xt=urn:btih:c693df61ab7547ed58ed4f8264c1358b1e25cf6a&dn=mini-gutenberg-10mb.tar.gz' +
            '&tr=wss%3A%2F%2Ftracker.openwebtorrent.com' +
            '&tr=wss%3A%2F%2Ftracker.webtorrent.dev' +
            '&tr=wss%3A%2F%2Ftracker.btorrent.xyz' +
            '&tr=wss%3A%2F%2Ftracker.fastcast.nz' +
            '&tr=wss%3A%2F%2Ftracker.files.fm%3A7073%2Fannounce';
        const MAGNET_PRESETS = {
            full: {
                id: 'full',
                label: 'Full Gutenberg (10GB)',
                magnet: DEFAULT_MAGNET,
                infoHash: 'a7bb7a777b775c6f7205e90b57c44b014a4e5f0c',
                description: 'Complete 80k title archive'
            },
            mini: {
                id: 'mini',
                label: 'Mini Sample (10MB)',
                magnet: MINI_ARCHIVE_MAGNET,
                infoHash: 'c693df61ab7547ed58ed4f8264c1358b1e25cf6a',
                description: '10 demo books for quick testing'
            }
        };

        if (typeof window.WebTorrent === 'undefined') {
            const message = 'WebTorrent library failed to load. Please use a modern Chromium- or Firefox-based browser.';
            console.error(message);
            alert(message);
        }

        console.log('%cüìö POC12 - Block Diagnostics Lab', 'background: #667eea; color: white; font-size: 14px; font-weight: bold; padding: 4px 8px; border-radius: 4px;');

        if (client) {
            client.on('warning', (warning) => {
                const message = (warning && warning.message) ? warning.message : String(warning);
                if (seenTorrentWarnings.has(message)) {
                    return;
                }
                seenTorrentWarnings.add(message);

                if (message.includes('tracker') || message.includes('WebSocket')) {
                    log(`‚ö†Ô∏è Tracker warning: ${message}`);
                } else {
                    log(`‚ö†Ô∏è WebTorrent warning: ${message}`);
                }
                console.warn('WebTorrent warning:', warning);
            });

            client.on('error', (error) => {
                log(`‚ùå WebTorrent client error: ${error.message}`);
                console.error('WebTorrent error:', error);
            });
        }

        function updateInfoHashDisplay(infoHash) {
            currentInfoHash = infoHash || null;
            const infoHashEl = document.getElementById('infoHashLine');
            if (!infoHashEl) return;

            if (infoHash) {
                infoHashEl.textContent = `InfoHash: ${infoHash}`;
                catalogSummary.infoHash = infoHash;
            } else {
                infoHashEl.textContent = 'InfoHash: ‚Äî';
                catalogSummary.infoHash = null;
            }
            refreshDownloadCard();
            refreshCatalogCard();
        }

        function isArchiveReady() {
            if (localArchiveFile) return true;
            if (currentTorrent && currentTorrent.progress === 1) return true;
            return false;
        }

        function normalizeMagnet(magnetLink) {
            if (!magnetLink) return magnetLink;

            let trimmed = magnetLink.trim();

            if (/%[0-9a-fA-F]{2}/.test(trimmed)) {
                try {
                    const decoded = decodeURIComponent(trimmed);
                    if (decoded) {
                        trimmed = decoded;
                    }
                } catch (error) {
                    console.warn('Failed to decode magnet components, keeping original string', error);
                }
            }

            if (trimmed.startsWith('magnet:?')) {
                return trimmed;
            }

            if (trimmed.startsWith('magnet:')) {
                const rest = trimmed.slice('magnet:'.length);
                if (rest.startsWith('?')) {
                    return `magnet:${rest}`;
                }
                return `magnet:?${rest.replace(/^\?+/, '')}`;
            }

            if (trimmed.startsWith('?')) {
                return `magnet:${trimmed}`;
            }

            if (trimmed.startsWith('xt=')) {
                return `magnet:?${trimmed}`;
            }

            // If it's just a bare info hash, build a minimal magnet
            const infoHashMatch = trimmed.match(/^[0-9a-fA-F]{40}$/);
            if (infoHashMatch) {
                return `magnet:?xt=urn:btih:${trimmed}`;
            }

            return trimmed;
        }

        function magnetForDisplay(magnetLink) {
            if (!magnetLink) return '';
            try {
                return decodeURIComponent(magnetLink);
            } catch (error) {
                return magnetLink;
            }
        }

        function truncateMiddle(value, maxLength = 70) {
            if (!value) return '';
            if (value.length <= maxLength) return value;
            const half = Math.floor((maxLength - 3) / 2);
            return `${value.slice(0, half)}...${value.slice(-half)}`;
        }

        function updateDownloadStatus(message) {
            const statusEl = document.getElementById('downloadStatusLine');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        function refreshDownloadCard() {
            const archiveEl = document.getElementById('downloadArchive');
            const speedEl = document.getElementById('downloadSpeed');
            const peersEl = document.getElementById('downloadPeers');
            const uploadEl = document.getElementById('downloadUpload');
            const magnetEl = document.getElementById('downloadMagnet');
            const infoHashEl = document.getElementById('downloadInfoHash');
            const pieceMapEl = document.getElementById('pieceMap');

            const totalSizeEl = document.getElementById('downloadTotalSize');

            if (!archiveEl || !speedEl || !peersEl || !uploadEl || !magnetEl || !infoHashEl || !pieceMapEl || !totalSizeEl) {
                return;
            }

            if (currentTorrent) {
                const totalBytes = currentTorrent.length || 0;
                const downloadedBytes = currentTorrent.downloaded || 0;
                const uploadedBytes = currentTorrent.uploaded || 0;
                const speedBytes = currentTorrent.downloadSpeed || 0;
                const progressPercent = totalBytes ? ((downloadedBytes / totalBytes) * 100) : 0;

                archiveEl.textContent = totalBytes
                    ? `${formatBytes(downloadedBytes)} / ${formatBytes(totalBytes)} (${progressPercent.toFixed(1)}%)`
                    : `${formatBytes(downloadedBytes)}`;
                speedEl.textContent = speedBytes ? `${formatBytes(speedBytes)}/s` : '0 B/s';
                peersEl.textContent = `${currentTorrent.numPeers} peer${currentTorrent.numPeers === 1 ? '' : 's'}`;
                uploadEl.textContent = formatBytes(uploadedBytes);
                infoHashEl.textContent = currentTorrent.infoHash || currentInfoHash || '‚Äî';
                magnetEl.textContent = activeDownload.magnet ? truncateMiddle(magnetForDisplay(activeDownload.magnet)) : '‚Äî';
                totalSizeEl.textContent = totalBytes ? formatBytes(totalBytes) : '‚Äî';

                updatePieceMap(currentTorrent);

            } else if (localArchiveFile) {
                archiveEl.textContent = `${localArchiveFile.name} (${formatBytes(localArchiveFile.size)})`;
                speedEl.textContent = '‚Äî';
                peersEl.textContent = '‚Äî';
                uploadEl.textContent = '‚Äî';
                infoHashEl.textContent = currentInfoHash || '‚Äî';
                magnetEl.textContent = activeDownload.magnet ? truncateMiddle(magnetForDisplay(activeDownload.magnet)) : 'Local file';
                totalSizeEl.textContent = formatBytes(localArchiveFile.size || 0);
                updatePieceMap(null);
                updateDownloadStatus('üìÅ Local archive loaded.');
            } else {
                archiveEl.textContent = '‚Äî';
                speedEl.textContent = '‚Äî';
                peersEl.textContent = '‚Äî';
                uploadEl.textContent = '‚Äî';
                infoHashEl.textContent = currentInfoHash || '‚Äî';
                magnetEl.textContent = activeDownload.magnet ? truncateMiddle(magnetForDisplay(activeDownload.magnet)) : '‚Äî';
                updatePieceMap(null);
                totalSizeEl.textContent = '‚Äî';
                const statusMessage = hasStartedDownload
                    ? 'No active downloads.'
                    : 'Ready. Click "Start Download" or load a local file.';
                updateDownloadStatus(statusMessage);
            }
        }

        function applyMagnetPreset(presetId) {
            const preset = MAGNET_PRESETS[presetId];
            if (!preset) return;

            const input = document.getElementById('magnetInput');
            if (input) {
                input.value = preset.magnet;
                input.style.fontSize = '0.75rem';
            }

            loadedMagnetLink = null;
            activeDownload.magnet = preset.magnet;
            updateDownloadStatus(`Preset loaded: ${preset.label}. Click "Start Download" to begin.`);
            log(`üéØ Magnet preset selected: ${preset.label} (${preset.infoHash})`);
            updateInfoHashDisplay(preset.infoHash);
            setBackgroundFromHash(preset.infoHash);
            refreshDownloadCard();

            if (presetId === 'mini') {
                log('‚ö° Auto-starting Mini Sample download');
                startDownload();
            }
        }

        function clearCachedBooks() {
            if (!catalogBooks || catalogBooks.length === 0) return;
            cachedBookCount = 0;
            catalogBooks.forEach((book) => {
                book.cached = false;
                book.content = null;
            });
            showLibrary();
        }

        function refreshCachedBookList() {
            if (!currentDisplayedBooks || currentDisplayedBooks.length === 0) return;
            const booksToShow = currentDisplayedBooks.slice();
            displayBooks(booksToShow);
        }

        function initProgressiveExtraction() {
            if (progressiveExtraction && progressiveExtraction.inflater) {
                return;
            }
            progressiveExtraction = {
                inflater: new pako.Inflate({ to: 'array' }),
                tarBuffer: new Uint8Array(0),
                lastByteOffset: 0,
                extractedPaths: new Set(),
                bytesInflated: 0,
                filesParsed: 0,
                enabled: true
            };
            progressiveExtraction.inflater.onData = (chunk) => {
                handleDecompressedChunk(chunk);
            };
        }

        function disableProgressiveExtraction(options = {}) {
            if (!progressiveExtraction) {
                return;
            }
            if (progressiveExtraction.inflater) {
                progressiveExtraction.inflater.onData = null;
            }
            if (options.reset) {
                progressiveExtraction = null;
                return;
            }
            progressiveExtraction.enabled = false;
            progressiveExtraction.tarBuffer = new Uint8Array(0);
        }

        function concatUint8Arrays(a, b) {
            if (!a || a.length === 0) return b || new Uint8Array(0);
            if (!b || b.length === 0) return a || new Uint8Array(0);
            const combined = new Uint8Array(a.length + b.length);
            combined.set(a, 0);
            combined.set(b, a.length);
            return combined;
        }

        function handleDecompressedChunk(chunk) {
            if (!progressiveExtraction || !chunk || chunk.length === 0) {
                return;
            }
            const data = chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk);
            progressiveExtraction.bytesInflated += data.length;
            progressiveExtraction.tarBuffer = concatUint8Arrays(progressiveExtraction.tarBuffer, data);
            processTarBuffer();
            if (progressiveExtraction.bytesInflated >= MAX_PROGRESSIVE_BYTES) {
                log('üõë Progressive extraction byte cap reached. Further files will unlock once the archive finishes.');
                disableProgressiveExtraction();
            }
        }

        function processTarBuffer() {
            if (!progressiveExtraction || !progressiveExtraction.tarBuffer || progressiveExtraction.tarBuffer.length < 512) {
                return;
            }

            let buffer = progressiveExtraction.tarBuffer;
            let offset = 0;

            while (buffer.length - offset >= 512) {
                const headerBlock = buffer.subarray(offset, offset + 512);

                if (isTarEndBlock(headerBlock)) {
                    offset += 512;
                    continue;
                }

                const header = parseTarHeader(headerBlock);
                if (!header) {
                    break;
                }

                const totalEntrySize = 512 + header.paddedSize;
                if (buffer.length - offset < totalEntrySize) {
                    break;
                }

                const isRegularFile = header.typeFlag === 0 || header.typeFlag === 48; // '\0' or '0'
                if (isRegularFile && header.size > 0) {
                    const fileData = buffer.subarray(offset + 512, offset + 512 + header.size);
                    handleExtractedTarFile(header.name, fileData);
                }

                offset += totalEntrySize;
                progressiveExtraction.filesParsed += 1;
            }

            if (offset > 0) {
                progressiveExtraction.tarBuffer = buffer.slice(offset);
            }
        }

        function parseTarHeader(block) {
            if (!block || block.length < 512) {
                return null;
            }

            const name = readTarString(block.subarray(0, 100));
            const prefix = readTarString(block.subarray(345, 500));
            const fullName = prefix ? `${prefix}/${name}` : name;

            const sizeString = readTarString(block.subarray(124, 136)).trim();
            let size = 0;
            if (sizeString) {
                const clean = sizeString.replace(/\0.*$/, '');
                size = parseInt(clean || '0', 8);
                if (Number.isNaN(size)) {
                    size = 0;
                }
            }
            const paddedSize = Math.ceil(size / 512) * 512;
            const typeFlag = block[156];

            return {
                name: fullName,
                size,
                paddedSize,
                typeFlag
            };
        }

        function readTarString(bytes) {
            if (!bytes) return '';
            let end = 0;
            while (end < bytes.length && bytes[end] !== 0) {
                end += 1;
            }
            if (end === 0) return '';
            return tarTextDecoder.decode(bytes.subarray(0, end));
        }

        function isTarEndBlock(block) {
            if (!block) return false;
            for (let i = 0; i < block.length; i += 1) {
                if (block[i] !== 0) {
                    return false;
                }
            }
            return true;
        }

        function handleExtractedTarFile(name, fileData) {
            if (!name || !fileData || fileData.length === 0) {
                return;
            }
            if (!progressiveExtraction || progressiveExtraction.extractedPaths.has(name)) {
                return;
            }
            if (progressiveExtraction.extractedPaths.size >= MAX_CACHED_BOOKS) {
                return;
            }
            const match = name.match(/(?:^|\/)(?:pg)?(\d+)(?:-.*)?\.txt$/i);
            if (!match) {
                return;
            }
            const etextNo = parseInt(match[1], 10);
            if (!Number.isFinite(etextNo) || !catalogIndexByEtext || !catalogIndexByEtext.has(etextNo)) {
                return;
            }
            const book = catalogIndexByEtext.get(etextNo);
            if (!book) {
                return;
            }

            try {
                const content = tarTextDecoder.decode(fileData);
                progressiveExtraction.extractedPaths.add(name);
                const wasCached = !!book.cached;
                book.cached = true;
                book.content = content;
                if (!wasCached) {
                    cachedBookCount += 1;
                }
                log(`üìó Cached "${book.title}" (pg${etextNo}) from progressive blocks`);
                if (progressiveExtraction.extractedPaths.size >= MAX_CACHED_BOOKS) {
                    log('üõë Progressive cache limit reached. Holding remaining files until the archive finishes.');
                    disableProgressiveExtraction();
                }
                refreshCatalogCard();
                refreshCachedBookList();
            } catch (err) {
                console.warn(`Failed to decode ${name}:`, err);
            }
        }

        async function attemptProgressiveExtraction(file, downloadedBytes) {
            if (!file || !downloadedBytes || downloadedBytes <= 0) {
                return;
            }
            if (!catalogIndexByEtext || catalogIndexByEtext.size === 0) {
                return;
            }
            if (progressiveExtraction && progressiveExtraction.enabled === false) {
                return;
            }
            if (progressiveExtraction && progressiveExtraction.extractedPaths && progressiveExtraction.extractedPaths.size >= MAX_CACHED_BOOKS) {
                return;
            }
            if (progressiveExtraction && progressiveExtraction.bytesInflated >= MAX_PROGRESSIVE_BYTES) {
                return;
            }

            if (!progressiveExtraction) {
                initProgressiveExtraction();
            }

            if (!progressiveExtraction) {
                return;
            }

            const bytesAvailable = downloadedBytes - progressiveExtraction.lastByteOffset;
            if (bytesAvailable <= 0) {
                return;
            }
            if (bytesAvailable <= 32 * 1024) {
                return;
            }

            const start = progressiveExtraction.lastByteOffset;
            const end = downloadedBytes - 1;

            try {
                await new Promise((resolve, reject) => {
                    let settled = false;
                    const finish = () => {
                        if (!settled) {
                            settled = true;
                            resolve();
                        }
                    };
                    const fail = (err) => {
                        if (!settled) {
                            settled = true;
                            reject(err);
                        }
                    };
                    const stream = file.createReadStream({ start, end });
                    stream.on('data', (chunk) => {
                        if (!progressiveExtraction || progressiveExtraction.enabled === false || !progressiveExtraction.inflater) {
                            stream.destroy();
                            finish();
                            return;
                        }
                        const data = chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk);
                        progressiveExtraction.lastByteOffset += data.length;
                        try {
                            progressiveExtraction.inflater.push(data, false);
                            if (progressiveExtraction.inflater.err) {
                                fail(new Error(progressiveExtraction.inflater.msg || 'Unknown inflate error'));
                                return;
                            }
                        } catch (err) {
                            fail(err);
                            return;
                        }
                        if (progressiveExtraction && progressiveExtraction.enabled === false) {
                            stream.destroy();
                            finish();
                        }
                    });
                    stream.on('end', finish);
                    stream.on('close', finish);
                    stream.on('error', fail);
                });
            } catch (error) {
                log(`‚ö†Ô∏è Progressive extraction failed: ${error.message}`);
                console.error('Progressive extraction error:', error);
                disableProgressiveExtraction();
            }
        }

        function sanitizeMagnet(magnetLink) {
            if (!magnetLink || !magnetLink.includes('?')) {
                return magnetLink;
            }

            try {
                const questionIndex = magnetLink.indexOf('?');
                const prefix = magnetLink.slice(0, questionIndex);
                const query = magnetLink.slice(questionIndex + 1);
                const parts = query.split('&').filter(Boolean);
                const cleanedPairs = [];
                const seenTrackers = new Set();

                for (const part of parts) {
                    const equalIndex = part.indexOf('=');
                    const rawKey = equalIndex >= 0 ? part.slice(0, equalIndex) : part;
                    const rawValue = equalIndex >= 0 ? part.slice(equalIndex + 1) : '';
                    const key = rawKey.trim();
                    if (!key) continue;

                    const lowerKey = key.toLowerCase();

                    const decodeSafe = (value) => {
                        try {
                            return decodeURIComponent(value);
                        } catch {
                            return value;
                        }
                    };

                    if (lowerKey === 'tr') {
                        const decodedTracker = decodeSafe(rawValue);
                        if (seenTrackers.has(decodedTracker) || seenTrackers.size >= 10) {
                            continue;
                        }
                        seenTrackers.add(decodedTracker);
                        cleanedPairs.push(`${key}=${encodeURIComponent(decodedTracker)}`);
                    } else if (lowerKey === 'xt') {
                        const decodedXt = decodeSafe(rawValue);
                        if (!decodedXt) continue;
                        if (decodedXt.startsWith('urn:')) {
                            cleanedPairs.push(`${key}=${decodedXt}`);
                        } else {
                            cleanedPairs.push(`${key}=${encodeURIComponent(decodedXt)}`);
                        }
                    } else {
                        if (rawValue === '') {
                            cleanedPairs.push(key);
                        } else {
                            const decodedValue = decodeSafe(rawValue);
                            cleanedPairs.push(`${key}=${encodeURIComponent(decodedValue)}`);
                        }
                    }
                }

                const separator = prefix.endsWith('?') ? '' : '?';
                return `${prefix}${separator}${cleanedPairs.join('&')}`;
            } catch (error) {
                console.warn('Failed to sanitize magnet link, using original', error);
                return magnetLink;
            }
        }

        function extractTrackersFromMagnet(magnetLink) {
            if (!magnetLink || !magnetLink.includes('?')) {
                return [];
            }

            try {
                const questionIndex = magnetLink.indexOf('?');
                const query = magnetLink.slice(questionIndex + 1);
                const params = new URLSearchParams(query);
                const trackers = [];
                for (const [key, value] of params.entries()) {
                    if (key.toLowerCase() === 'tr') {
                        trackers.push(value);
                    }
                }
                return trackers;
            } catch (error) {
                console.warn('Failed to extract trackers from magnet', error);
                return [];
            }
        }

        function shortPeerId(peerId) {
            if (!peerId) return null;

            if (typeof peerId === 'string') {
                return peerId.slice(0, 12);
            }

            try {
                const view = peerId.buffer
                    ? new Uint8Array(peerId.buffer, peerId.byteOffset || 0, Math.min(6, peerId.byteLength || peerId.length || 0))
                    : new Uint8Array(peerId);
                return Array.from(view, (byte) => byte.toString(16).padStart(2, '0')).join('');
            } catch (error) {
                return null;
            }
        }

        function describePeerConnection(wire, addr) {
            if (addr && addr !== '127.0.0.1:0') {
                return addr;
            }

            if (wire && wire.remoteAddress) {
                return wire.remoteAddress;
            }

            const id = shortPeerId(wire && wire.peerId);
            return id ? `browser#${id}` : 'browser-peer';
        }

        // Simple string hash function (cyrb53)
        function hashString(str) {
            let h1 = 0xdeadbeef, h2 = 0x41c6ce57;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
            const hash = 4294967296 * (2097151 & h2) + (h1 >>> 0);
            // Convert to 40-char hex string (like InfoHash)
            return hash.toString(16).padStart(16, '0').repeat(3).substring(0, 40);
        }

        // Load saved background color and catalog on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Set background from hash of our own source code (static parts only)
            // Hash the script content which doesn't change at runtime
            const scripts = Array.from(document.getElementsByTagName('script'))
                .map(s => s.textContent)
                .join('');
            const sourceHash = hashString(scripts);
            setBackgroundFromHash(sourceHash);
            console.log(`üé® Color seed from source hash: ${sourceHash}`);

            refreshDownloadCard();
            updateDownloadStatus('Ready. Click "Start Download" or load a local file.');
            refreshCatalogCard();
            refreshBrowserFilesystem().catch(() => {
                const fsDiv = document.getElementById('browserFilesystem');
                if (fsDiv && fsDiv.innerHTML.trim() === '') {
                    fsDiv.innerHTML = '<div style="color:#999;">Unable to read browser storage</div>';
                }
            });
            loadCatalog(); // Auto-load catalog
            // Removed auto-start: startDownload();
        });

        function hashToColor(hash) {
            // Convert InfoHash to two colors for gradient
            if (!hash || hash.length < 40) {
                return null;
            }

            // Use first 6 chars for color1, chars 20-26 for color2
            const color1 = '#' + hash.substring(0, 6);
            const color2 = '#' + hash.substring(20, 26);

            return { color1, color2 };
        }

        function setBackgroundFromHash(hash) {
            const colors = hashToColor(hash);
            if (!colors) return;

            const gradient = `linear-gradient(135deg, ${colors.color1} 0%, ${colors.color2} 100%)`;
            document.body.style.background = gradient;

            // Save to localStorage
            localStorage.setItem('poc11_bg_color', JSON.stringify(colors));

            log(`üé® Background: ${colors.color1} ‚Üí ${colors.color2}`);
        }

        function loadBackgroundColor() {
            const saved = localStorage.getItem('poc11_bg_color');
            if (!saved) return;

            const colors = JSON.parse(saved);
            const gradient = `linear-gradient(135deg, ${colors.color1} 0%, ${colors.color2} 100%)`;
            document.body.style.background = gradient;

            console.log(`üé® Loaded background color: ${colors.color1} ‚Üí ${colors.color2}`);
        }

        async function loadCatalog() {
            updateStatus('üìö Loading catalog...');

            try {
                const response = await fetch('GUTINDEX.ALL.new');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const text = await response.text();
                const parsedBooks = GutIndexParser.parseIndex(text);
                catalogBooks = parsedBooks.map((book) => ({
                    ...book,
                    cached: false,
                    content: null
                }));
                catalogIndexByEtext = new Map();
                catalogBooks.forEach((book) => {
                    catalogIndexByEtext.set(book.etextNo, book);
                });

                // Extract and display metadata
                const fileSize = text.length;
                const lastModified = response.headers.get('Last-Modified') || 'Unknown';
                const contentType = response.headers.get('Content-Type') || 'text/plain';

                // Calculate a simple hash for verification
                const catalogHash = hashString(text).substring(0, 8);

                updateStatus(`‚úÖ Catalog loaded: ${catalogBooks.length.toLocaleString()} books`);
                showLibrary();
                displayCatalogMetadata({
                    books: catalogBooks.length,
                    fileSize: fileSize,
                    lastModified: lastModified,
                    contentType: contentType,
                    hash: catalogHash,
                    source: 'GUTINDEX.ALL.new'
                });

            } catch (error) {
                updateStatus(`‚ùå Error loading catalog: ${error.message}`);
                console.error('Catalog load error:', error);
            }
        }

        function displayCatalogMetadata(meta) {
            const metadataDiv = document.getElementById('catalogMetadata');
            metadataDiv.innerHTML = `
                <div style="margin-bottom: 0.5rem;"><strong>üìÅ Source:</strong> ${meta.source}</div>
                <div style="margin-bottom: 0.5rem;"><strong>üìö Books:</strong> ${meta.books.toLocaleString()}</div>
                <div style="margin-bottom: 0.5rem;"><strong>üíæ File Size:</strong> ${formatBytes(meta.fileSize)}</div>
                <div style="margin-bottom: 0.5rem;"><strong>üìÖ Last Modified:</strong> ${meta.lastModified}</div>
                <div style="margin-bottom: 0.5rem;"><strong>üìù Content Type:</strong> ${meta.contentType}</div>
                <div><strong>üîê Hash (first 8):</strong> ${meta.hash}</div>
            `;
            log(`üìä Catalog metadata: ${meta.books.toLocaleString()} books, ${formatBytes(meta.fileSize)}, hash: ${meta.hash}`);
        }

        function updateStatus(message) {
            document.getElementById('statusLine').textContent = message;
        }

        function handleTorrentFile(file) {
            if (!file) {
                alert('‚ö†Ô∏è No file selected');
                return;
            }
            if (!client) {
                alert('‚ùå WebTorrent is not available in this browser. Please try the latest Firefox or Chromium.');
                return;
            }
            log(`üî• Loading .torrent file: ${file.name}`);
            updateDownloadStatus(`üî• Loading torrent file: ${file.name}...`);

            const reader = new FileReader();
            reader.onerror = (e) => {
                alert(`‚ùå Error reading torrent file: ${e.target.error}`);
                log(`‚ùå FileReader error: ${e.target.error}`);
            };
            reader.onload = async (e) => {
                const torrentBuffer = new Uint8Array(e.target.result);
                log(`üìÑ Torrent file read: ${torrentBuffer.length} bytes`);

                try {
                    // Parse .torrent file and calculate InfoHash
                    log(`üîç Parsing torrent file...`);
                    const metadata = await calculateInfoHash(torrentBuffer.buffer);
                    const magnetLink = createMagnetLink(metadata);

                    log(`‚úÖ Torrent file loaded: ${file.name}`);
                    log(`üîó InfoHash: ${metadata.infoHash}`);
                    log(`üìã Name: ${metadata.name}`);
                    log(`üì° Trackers: ${metadata.announceList.length > 0 ? metadata.announceList.flat().length : (metadata.announce ? 1 : 0)}`);
                    log(`üß≤ Magnet link: ${magnetLink.substring(0, 100)}...`);

                    alert(`‚úÖ Torrent file parsed!\n\nFile: ${file.name}\nName: ${metadata.name}\nInfoHash: ${metadata.infoHash}\n\nNow click "Start Download" to begin.`);

                    // Store the magnet link for later use
                    loadedMagnetLink = magnetLink;
                    activeDownload.magnet = magnetLink;
                    refreshDownloadCard();
                    updateDownloadStatus('‚úÖ Torrent file loaded. Click "Start Download" to connect.');

                    // Show magnet link in input
                    document.getElementById('magnetInput').value = magnetForDisplay(magnetLink);
                    document.getElementById('magnetInput').style.fontSize = '0.75rem';

                    // Set background color from InfoHash
                    setBackgroundFromHash(metadata.infoHash);
                    updateInfoHashDisplay(metadata.infoHash);

                } catch (err) {
                    alert(`‚ùå Error parsing torrent: ${err.message}\n\nThe file may be corrupted or in an unsupported format.`);
                    log(`‚ùå Error parsing torrent: ${err.message}`);
                    console.error('Torrent parse error:', err);
                    updateDownloadStatus('‚ùå Failed to parse torrent file');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function loadLocalFile() {
            const fileInput = document.getElementById('localFileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file first');
                return;
            }

            localArchiveFile = file;
            handleSeedContentFile(file);
            log(`üìÅ Loading local file: ${file.name} (${formatBytes(file.size)})`);

            // Check if there's an active torrent download that matches this file
            if (currentTorrent && currentTorrent.length && currentTorrent.length === file.size) {
                log(`‚ú® Local file size matches active torrent! (${formatBytes(file.size)})`);
                log(`üîÑ Switching from download to seeding mode...`);

                // Store torrent metadata before destroying
                const torrentInfoHash = currentTorrent.infoHash;
                const torrentMagnet = currentTorrent.magnetURI;
                const torrentName = currentTorrent.name;

                // Stop current download
                if (currentTorrent) {
                    currentTorrent.destroy();
                    currentTorrent = null;
                }

                // Clear intervals
                if (torrentStatsInterval) {
                    clearInterval(torrentStatsInterval);
                    torrentStatsInterval = null;
                }

                log(`üå± Starting to seed local file as torrent...`);
                updateDownloadStatus('üå± Seeding matched local file...');

                // Use the loaded file to seed
                seedContentFile = file;

                // For now, just process the local file normally
                // In future, we could auto-seed if we have the .torrent file too
                processLocalArchive(file);

                log(`üí° Tip: Load the .torrent file in the Seed section to start seeding!`);
                return;
            }

            log(`üîì Starting extraction...`);

            // Skip download, go straight to extraction
            processLocalArchive(file);
        }

        // Seeding functions
        function handleSeedTorrentFile(file) {
            if (!file) {
                alert('‚ö†Ô∏è No torrent file selected');
                return;
            }
            if (!client) {
                alert('‚ùå WebTorrent is not available in this browser. Please try the latest Firefox or Chromium.');
                return;
            }
            log(`üå± Loading .torrent file for seeding: ${file.name}`);

            const reader = new FileReader();
            reader.onerror = (e) => {
                alert(`‚ùå Error reading torrent file: ${e.target.error}`);
                log(`‚ùå FileReader error: ${e.target.error}`);
            };
            reader.onload = async (e) => {
                const torrentBuffer = new Uint8Array(e.target.result);
                log(`üìÑ Torrent file read: ${torrentBuffer.length} bytes`);

                try {
                    // Parse .torrent file
                    log(`üîç Parsing torrent file...`);
                    const metadata = await calculateInfoHash(torrentBuffer.buffer);
                    const parsed = parseBencode(torrentBuffer.buffer);
                    const torrent = parsed.value;

                    // Extract detailed metadata
                    const info = torrent.info;
                    const files = info.files || [{ length: info.length, path: [info.name] }];
                    const totalLength = info.files ? info.files.reduce((sum, f) => sum + f.length, 0) : info.length;

                    // Calculate number of pieces from pieces buffer (each SHA-1 hash is 20 bytes)
                    let pieceCount = 0;
                    if (info.pieces) {
                        const piecesBuffer = info.pieces instanceof Uint8Array ? info.pieces : new Uint8Array(info.pieces);
                        pieceCount = Math.floor(piecesBuffer.length / 20);
                    }

                    seedTorrentMetadata = {
                        infoHash: metadata.infoHash,
                        magnetURI: createMagnetLink(metadata),
                        name: info.name || 'unknown',
                        files: files.map(f => ({
                            name: Array.isArray(f.path) ? f.path.join('/') : f.path,
                            length: f.length,
                            path: Array.isArray(f.path) ? f.path.join('/') : f.path
                        })),
                        announce: metadata.announce || torrent.announce,
                        pieceLength: info['piece length'] || 0,
                        lastPieceLength: totalLength % (info['piece length'] || 1) || (info['piece length'] || 0),
                        pieces: pieceCount,
                        length: totalLength,
                        created: torrent['creation date'] || 0,
                        createdBy: metadata.createdBy || torrent['created by'] || '',
                        comment: metadata.comment || torrent.comment || ''
                    };
                    seedTorrentFile = file;

                    log(`‚úÖ Torrent metadata loaded: ${seedTorrentMetadata.name}`);
                    log(`üîó InfoHash: ${metadata.infoHash}`);
                    log(`üì¶ Size: ${formatBytes(totalLength)}`);
                    log(`üß© Pieces: ${seedTorrentMetadata.pieces}`);

                    const statusEl = document.getElementById('seedTorrentStatus');
                    if (statusEl) {
                        statusEl.textContent = `‚úÖ ${file.name}`;
                        statusEl.style.color = '#2e7d32';
                    }

                    // Show seeding panel when any file is loaded
                    const panel = document.getElementById('seedingStatusPanel');
                    if (panel) panel.style.display = 'block';

                    // Show debug panel with technical details
                    displaySeedDebugInfo(seedTorrentMetadata);

                    // Check if we can enable seeding button
                    checkSeedingReady();

                } catch (err) {
                    alert(`‚ùå Error parsing torrent: ${err.message}\n\nThe file may be corrupted or in an unsupported format.`);
                    log(`‚ùå Error parsing torrent: ${err.message}`);
                    console.error('Torrent parse error:', err);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function displaySeedDebugInfo(meta) {
            const panel = document.getElementById('seedDebugPanel');
            const content = document.getElementById('seedDebugContent');

            if (!panel || !content) return;

            let html = '<div style="line-height: 1.6;">';
            const trackers = meta.announce
                ? (Array.isArray(meta.announce) ? meta.announce : [meta.announce]).filter(Boolean)
                : [];

            // InfoHash
            html += `<div style="margin-bottom: 0.5rem;"><strong style="color: #d32f2f;">InfoHash:</strong><br>`;
            html += `<span style="color: #1976d2;">${meta.infoHash}</span></div>`;

            // Name
            html += `<div style="margin-bottom: 0.5rem;"><strong style="color: #d32f2f;">Name:</strong><br>`;
            html += `${meta.name}</div>`;

            // Total Size
            html += `<div style="margin-bottom: 0.5rem;"><strong style="color: #d32f2f;">Total Size:</strong> `;
            html += `${formatBytes(meta.length)}</div>`;

            // Piece Info
            html += `<div style="margin-bottom: 0.5rem;"><strong style="color: #d32f2f;">Pieces:</strong> `;
            html += `${meta.pieces} pieces √ó ${formatBytes(meta.pieceLength)}`;
            if (meta.lastPieceLength && meta.lastPieceLength !== meta.pieceLength) {
                html += ` (last: ${formatBytes(meta.lastPieceLength)})`;
            }
            html += `</div>`;

            // Files
            html += `<div style="margin-bottom: 0.5rem;"><strong style="color: #d32f2f;">Files:</strong> ${meta.files.length} file${meta.files.length !== 1 ? 's' : ''}</div>`;
            if (meta.files.length <= 10) {
                meta.files.forEach((f, idx) => {
                    html += `<div style="margin-left: 1rem; font-size: 0.7rem; color: #666;">`;
                    html += `${idx + 1}. ${f.path || f.name} (${formatBytes(f.length)})</div>`;
                });
            } else {
                html += `<div style="margin-left: 1rem; font-size: 0.7rem; color: #666;">`;
                html += `(${meta.files.length} files - showing first 3)</div>`;
                meta.files.slice(0, 3).forEach((f, idx) => {
                    html += `<div style="margin-left: 1rem; font-size: 0.7rem; color: #666;">`;
                    html += `${idx + 1}. ${f.path || f.name} (${formatBytes(f.length)})</div>`;
                });
            }

            // Trackers
            if (trackers.length > 0) {
                html += `<div style="margin-bottom: 0.5rem; margin-top: 0.5rem;"><strong style="color: #d32f2f;">Trackers:</strong> ${trackers.length}</div>`;
                trackers.slice(0, 5).forEach((tracker, idx) => {
                    html += `<div style="margin-left: 1rem; font-size: 0.7rem; color: #666;">${idx + 1}. ${tracker}</div>`;
                });
                if (trackers.length > 5) {
                    html += `<div style="margin-left: 1rem; font-size: 0.7rem; color: #999;">... and ${trackers.length - 5} more</div>`;
                }
            }

            // Creation Info
            if (meta.created) {
                html += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ddd;">`;
                html += `<strong style="color: #d32f2f;">Created:</strong> ${new Date(meta.created).toLocaleString()}</div>`;
            }
            if (meta.createdBy) {
                html += `<div style="margin-top: 0.25rem;"><strong style="color: #d32f2f;">Created By:</strong> ${meta.createdBy}</div>`;
            }
            if (meta.comment) {
                html += `<div style="margin-top: 0.25rem;"><strong style="color: #d32f2f;">Comment:</strong> ${meta.comment}</div>`;
            }

            // Magnet URI (truncated)
            html += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ddd;">`;
            html += `<strong style="color: #d32f2f;">Magnet URI:</strong><br>`;
            html += `<span style="font-size: 0.65rem; word-break: break-all; color: #1976d2;">${meta.magnetURI.substring(0, 150)}...</span></div>`;

            html += '</div>';

            content.innerHTML = html;
            panel.style.display = 'block';

            log(`üìä Debug panel updated with ${meta.pieces} pieces, ${meta.files.length} files, ${trackers.length} trackers`);
        }

        function handleSeedContentFile(file) {
            if (!file) return;
            seedContentFile = file;
            log(`üå± Loading content file for seeding: ${file.name} (${formatBytes(file.size)})`);

            const statusEl = document.getElementById('seedContentStatus');
            if (statusEl) {
                statusEl.textContent = `‚úÖ ${file.name} (${formatBytes(file.size)})`;
                statusEl.style.color = '#2e7d32';
            }

            // Show seeding panel when any file is loaded
            const panel = document.getElementById('seedingStatusPanel');
            if (panel) panel.style.display = 'block';

            // Check if we can enable seeding button
            checkSeedingReady();
        }

        function checkSeedingReady() {
            const btn = document.getElementById('startSeedingBtn');
            if (seedTorrentFile && seedContentFile && seedTorrentMetadata && btn) {
                btn.disabled = false;
                log(`‚úÖ Ready to seed! Both files loaded.`);
            }
        }

        function startSeeding() {
            if (!client) {
                alert('WebTorrent is not available in this browser.');
                return;
            }

            if (!seedTorrentFile || !seedContentFile || !seedTorrentMetadata) {
                alert('Please load both the .torrent file and the content file first.');
                return;
            }

            log(`üöÄ Starting to seed: ${seedTorrentMetadata.name}`);
            log(`üì¶ File size: ${formatBytes(seedContentFile.size)}`);
            log(`üîó InfoHash: ${seedTorrentMetadata.infoHash}`);

            // Stop any existing torrent
            if (currentTorrent) {
                log('üßπ Stopping previous torrent session');
                currentTorrent.destroy();
                currentTorrent = null;
            }

            if (torrentStatsInterval) {
                clearInterval(torrentStatsInterval);
                torrentStatsInterval = null;
            }

            // Use the content file as the archive - this makes books readable
            localArchiveFile = seedContentFile;
            processLocalArchive(seedContentFile);

            // Read the torrent file and add it to WebTorrent
            const reader = new FileReader();
            reader.onload = (e) => {
                const torrentBuffer = new Uint8Array(e.target.result);

                log(`üì° Adding torrent to announce seeding...`);

                // Add the torrent (this will start downloading, but we already have the file)
                // WebTorrent will verify pieces and announce to trackers that we're seeding
                currentTorrent = client.add(torrentBuffer, {
                    path: '/downloads',
                    maxWebConns: 10
                });

                log(`‚úÖ Torrent added, waiting for metadata...`);

                // Wait for metadata
                currentTorrent.on('metadata', () => {
                    log(`‚úÖ Metadata received, InfoHash: ${currentTorrent.infoHash}`);
                    log(`üì¶ Size: ${formatBytes(currentTorrent.length)}, Pieces: ${currentTorrent.pieces.length}`);

                    // Update UI
                    updateInfoHashDisplay(currentTorrent.infoHash);
                    setBackgroundFromHash(currentTorrent.infoHash);
                    activeDownload.magnet = currentTorrent.magnetURI;
                    document.getElementById('magnetInput').value = magnetForDisplay(currentTorrent.magnetURI);
                    updateDownloadStatus(`üå± Verifying local file... This may take a while.`);
                    refreshDownloadCard();

                    log(`‚ö†Ô∏è Note: WebTorrent will download the file again (it can't use your local file directly)`);
                    log(`üí° Once complete, it will automatically seed to other peers`);
                });

                // Setup event handlers
                currentTorrent.on('wire', (wire, addr) => {
                    const peerLabel = describePeerConnection(wire, addr);
                    log(`üîó Peer connected: ${peerLabel} | Total: ${currentTorrent.numPeers}`);
                    refreshDownloadCard();
                });

                currentTorrent.on('download', (bytes) => {
                    // Downloads are happening
                });

                currentTorrent.on('upload', (bytes) => {
                    log(`‚¨ÜÔ∏è Uploaded ${formatBytes(bytes)} to peers`);
                });

                currentTorrent.on('done', () => {
                    log(`‚úÖ Download/verification complete! Now seeding to ${currentTorrent.numPeers} peers`);
                    updateDownloadStatus(`üå± Seeding complete file to peers`);
                });

                currentTorrent.on('error', (err) => {
                    log(`‚ùå Seeding error: ${err.message}`);
                    console.error('Seeding error:', err);
                    updateDownloadStatus(`‚ùå Error: ${err.message}`);
                });

                // Update stats periodically
                torrentStatsInterval = setInterval(() => {
                    if (!currentTorrent) return;

                    const peers = currentTorrent.numPeers;
                    const uploaded = formatBytes(currentTorrent.uploaded);
                    const uploadSpeed = currentTorrent.uploadSpeed ? formatBytes(currentTorrent.uploadSpeed) : '0 B';
                    const downloaded = formatBytes(currentTorrent.downloaded);
                    const progress = currentTorrent.progress ? (currentTorrent.progress * 100).toFixed(1) : '0.0';

                    if (currentTorrent.progress < 1) {
                        updateDownloadStatus(`‚¨áÔ∏è Downloading: ${progress}% ‚Ä¢ ${downloaded} / ${formatBytes(currentTorrent.length)} ‚Ä¢ ${peers} peer${peers !== 1 ? 's' : ''}`);
                    } else {
                        updateDownloadStatus(`üå± Seeding ‚Ä¢ ${uploaded} uploaded ‚Ä¢ ${uploadSpeed}/s ‚Ä¢ ${peers} peer${peers !== 1 ? 's' : ''}`);
                    }
                    refreshDownloadCard();
                }, 1000);
            };
            reader.readAsArrayBuffer(seedTorrentFile);
        }

        function log(message) {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(message);
        }

        async function refreshBrowserFilesystem() {
            const fsDiv = document.getElementById('browserFilesystem');
            fsDiv.innerHTML = '<div style="color: #999;">Loading...</div>';

            let html = '';

            // 1. Storage Quota
            if (navigator.storage && navigator.storage.estimate) {
                try {
                    const estimate = await navigator.storage.estimate();
                    const usedMB = (estimate.usage / 1024 / 1024).toFixed(2);
                    const quotaMB = (estimate.quota / 1024 / 1024).toFixed(2);
                    const usedPercent = ((estimate.usage / estimate.quota) * 100).toFixed(1);
                    html += `<div style="margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #ddd;">`;
                    html += `<strong>üíæ Storage Quota:</strong><br>`;
                    html += `Used: ${usedMB} MB / ${quotaMB} MB (${usedPercent}%)<br>`;
                    html += `</div>`;
                } catch (e) {
                    html += `<div style="color: #999;">Storage API not available</div>`;
                }
            }

            // 2. Local Loaded Files
            html += `<div style="margin-bottom: 1rem;">`;
            html += `<strong>üìÅ Local Files:</strong><br>`;
            if (localArchiveFile) {
                const cachedBooksCount = catalogBooks.filter(b => b.cached).length;
                html += `<div style="margin-left: 1rem; margin-top: 0.25rem;">`;
                html += `1. ${localArchiveFile.name}<br>`;
                html += `   Status: loaded | Size: ${formatBytes(localArchiveFile.size)}<br>`;
                html += `   Type: ${localArchiveFile.type || 'application/gzip'}<br>`;
                if (cachedBooksCount > 0) {
                    html += `   Cached Books: ${cachedBooksCount} books extracted<br>`;
                }
                html += `</div>`;
            } else if (seedContentFile) {
                html += `<div style="margin-left: 1rem; margin-top: 0.25rem;">`;
                html += `1. ${seedContentFile.name} (seeding)<br>`;
                html += `   Status: seeding | Size: ${formatBytes(seedContentFile.size)}<br>`;
                html += `</div>`;
            } else {
                html += `<div style="margin-left: 1rem; color: #999;">No local files loaded</div>`;
            }
            html += `</div>`;

            // 3. WebTorrent Files
            html += `<div style="margin-bottom: 1rem;">`;
            html += `<strong>üåä WebTorrent Files:</strong><br>`;
            if (currentTorrent && currentTorrent.files && currentTorrent.files.length > 0) {
                currentTorrent.files.forEach((file, idx) => {
                    const displayName = file.path || file.name || '(unnamed file)';
                    const progress = file.progress !== undefined ? (file.progress * 100).toFixed(1) : '0.0';
                    const statusLabel = file.progress === 1 ? 'complete' : 'partial';
                    const downloadedSize = typeof file.downloaded === 'number' ? formatBytes(file.downloaded) : '‚Äî';
                    const totalSize = typeof file.length === 'number' ? formatBytes(file.length) : '‚Äî';
                    html += `<div style="margin-left: 1rem; margin-top: 0.25rem;">`;
                    html += `${idx + 1}. ${displayName}<br>`;
                    html += `   Status: ${statusLabel} | Size: ${totalSize} | Progress: ${progress}%<br>`;
                    html += `   Downloaded: ${downloadedSize}<br>`;
                    html += `</div>`;
                });
            } else if (currentTorrent) {
                html += `<div style="margin-left: 1rem; color: #999;">Torrent active ‚Ä¢ awaiting file metadata‚Ä¶</div>`;
            } else {
                html += `<div style="margin-left: 1rem; color: #999;">No active torrents</div>`;
            }
            html += `</div>`;

            // 4. LocalStorage
            html += `<div style="margin-bottom: 1rem;">`;
            html += `<strong>üóÑÔ∏è LocalStorage (${localStorage.length} items):</strong><br>`;
            if (localStorage.length > 0) {
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const value = localStorage.getItem(key);
                    const size = new Blob([value]).size;
                    html += `<div style="margin-left: 1rem; margin-top: 0.25rem;">`;
                    html += `${i + 1}. <code>${key}</code> (${formatBytes(size)})<br>`;
                    html += `</div>`;
                }
            } else {
                html += `<div style="margin-left: 1rem; color: #999;">Empty</div>`;
            }
            html += `</div>`;

            // 5. IndexedDB Databases
            html += `<div style="margin-bottom: 1rem;">`;
            html += `<strong>üóÉÔ∏è IndexedDB:</strong><br>`;
            if (indexedDB.databases) {
                try {
                    const databases = await indexedDB.databases();
                    if (databases.length > 0) {
                        databases.forEach((db, idx) => {
                            html += `<div style="margin-left: 1rem; margin-top: 0.25rem;">`;
                            html += `${idx + 1}. ${db.name} (v${db.version})<br>`;
                            html += `</div>`;
                        });
                    } else {
                        html += `<div style="margin-left: 1rem; color: #999;">No databases</div>`;
                    }
                } catch (e) {
                    html += `<div style="margin-left: 1rem; color: #999;">Error: ${e.message}</div>`;
                }
            } else {
                html += `<div style="margin-left: 1rem; color: #999;">indexedDB.databases() not supported</div>`;
            }
            html += `</div>`;

            fsDiv.innerHTML = html;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatTime(seconds) {
            if (seconds === Infinity) return '‚àû';
            if (isNaN(seconds)) return 'N/A';
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        let pieceMapInitialized = false;

        function updatePieceMap(torrent) {
            const pieceMap = document.getElementById('pieceMap');
            const pieceContainer = document.getElementById('pieceMapContainer');
            const summaryEl = document.getElementById('pieceSummary');
            const detailsEl = document.getElementById('pieceDetails');
            const blockStripEl = document.getElementById('blockStrip');
            if (!pieceMap || !pieceContainer) return;

            if (!torrent || !torrent.pieces || torrent.pieces.length === 0 || !torrent.bitfield) {
                pieceContainer.style.display = 'none';
                pieceMap.innerHTML = '';
                if (summaryEl) summaryEl.textContent = 'Waiting for data‚Ä¶';
                if (detailsEl) detailsEl.innerHTML = '';
                if (blockStripEl) {
                    blockStripEl.innerHTML = '';
                    blockStripEl.style.display = 'none';
                }
                return;
            }

            const totalPieces = torrent.pieces.length;

            if (!pieceMapInitialized || pieceMap.children.length !== totalPieces) {
                pieceMapInitialized = true;
                pieceMap.innerHTML = '';

                for (let i = 0; i < totalPieces; i++) {
                    const piece = document.createElement('div');
                    piece.title = `Piece ${i}`;
                    pieceMap.appendChild(piece);
                }
            }

            pieceContainer.style.display = '';

            const children = pieceMap.children;
            let piecesHave = 0;
            for (let i = 0; i < totalPieces; i++) {
                if (torrent.bitfield.get(i)) {
                    children[i].style.background = '#4caf50';
                    piecesHave++;
                } else {
                    children[i].style.background = '#e0e0e0';
                }
            }

            if (summaryEl) {
                const piecesPercent = (piecesHave / totalPieces) * 100;
                summaryEl.textContent = `${piecesHave} / ${totalPieces} pieces (${piecesPercent.toFixed(1)}%)`;
            }

            if (detailsEl) {
                detailsEl.innerHTML = '';
            }
            if (blockStripEl) {
                blockStripEl.innerHTML = '';
                blockStripEl.style.display = 'none';
            }
        }

        function startDownload() {
            log('üöÄ Starting download process...');
            if (!client) {
                alert('WebTorrent is not available in this browser. Please try the latest Firefox or Chromium.');
                return;
            }
            // Get magnet link from input or use loaded magnet or default
            const magnetInput = document.getElementById('magnetInput').value.trim();
            const normalizedMagnet = normalizeMagnet(magnetInput);
            const magnetLink = loadedMagnetLink || normalizedMagnet || DEFAULT_MAGNET;
            const sanitizedMagnet = sanitizeMagnet(magnetLink);
            const trackersFromMagnet = extractTrackersFromMagnet(sanitizedMagnet);
            const effectiveMagnet = sanitizedMagnet;
            hasStartedDownload = true;
            clearCachedBooks();
            disableProgressiveExtraction({ reset: true });
            refreshCatalogCard();
            refreshCachedBookList();
            activeDownload.magnet = effectiveMagnet;
            refreshDownloadCard();

            if (!loadedMagnetLink && normalizedMagnet && normalizedMagnet !== effectiveMagnet) {
                document.getElementById('magnetInput').value = magnetForDisplay(effectiveMagnet);
            }

            if (sanitizedMagnet !== magnetLink) {
                log('üßπ Deduplicated tracker list to stay under browser limits');
            }

            if (currentTorrent) {
                log('üßπ Stopping previous torrent session');
                currentTorrent.destroy();
                currentTorrent = null;
                pieceMapInitialized = false;
                const pieceMapEl = document.getElementById('pieceMap');
                if (pieceMapEl) pieceMapEl.innerHTML = '';
                const pieceContainer = document.getElementById('pieceMapContainer');
                if (pieceContainer) pieceContainer.style.display = 'none';
                updateTorrentInfo(null);
                updateDownloadStatus('Stopping previous download‚Ä¶');
                refreshDownloadCard();
            }

            if (torrentStatsInterval) {
                clearInterval(torrentStatsInterval);
                torrentStatsInterval = null;
            }
            updateInfoHashDisplay(null);
            updateDownloadStatus('‚öôÔ∏è Preparing download...');

            if (loadedMagnetLink) {
                log('üì• Starting WebTorrent download with loaded .torrent file...');
            } else {
                log('üì• Starting WebTorrent download...');
            }
            log(`üîó Magnet: ${effectiveMagnet.substring(0, 80)}...`);

            const torrentOptions = {
                path: '/downloads',
                maxWebConns: 10       // Max web seed connections
            };

            if (trackersFromMagnet.length === 0) {
                torrentOptions.announce = FALLBACK_TRACKERS;
            }

            currentTorrent = client.add(effectiveMagnet, torrentOptions);
            pieceMapInitialized = false;
            const pieceMapEl = document.getElementById('pieceMap');
            if (pieceMapEl) pieceMapEl.innerHTML = '';
            const pieceContainer = document.getElementById('pieceMapContainer');
            if (pieceContainer) pieceContainer.style.display = 'none';
            updateDownloadStatus('üîç Waiting for metadata...');

            currentTorrent.on('ready', () => {
                log(`‚úÖ Torrent ready!`);
                log(`üìä Total size: ${formatBytes(currentTorrent.length)}`);
                log(`üìÅ Files: ${currentTorrent.files.length}`);
                log(`üß© Pieces: ${currentTorrent.pieces.length} (${formatBytes(currentTorrent.pieceLength)} each)`);
                const trackerCount = currentTorrent.announce ? currentTorrent.announce.length : 0;
                log(`‚ö° Max connections: ${MAX_TORRENT_CONNECTIONS} | Tracker count: ${trackerCount}`);
                if (currentTorrent.infoHash && currentTorrent.infoHash !== currentInfoHash) {
                    updateInfoHashDisplay(currentTorrent.infoHash);
                    log(`üß≠ InfoHash: ${currentTorrent.infoHash}`);
                }
                updateDownloadStatus('üì¶ Metadata received. Downloading pieces...');
                updateTorrentInfo(currentTorrent);
                refreshDownloadCard();

                // Set background color from InfoHash
                setBackgroundFromHash(currentTorrent.infoHash);

                // Enable sequential downloading for progressive extraction
                if (currentTorrent.files.length > 0) {
                    const mainFile = currentTorrent.files[0];
                    mainFile.select(0); // Highest priority for sequential pieces
                    log(`üéØ Sequential downloading enabled for progressive extraction`);
                }
            });

            currentTorrent.on('wire', (wire, addr) => {
                const peerLabel = describePeerConnection(wire, addr);
                log(`üîó Peer connected: ${peerLabel} | Total: ${currentTorrent.numPeers}`);
                refreshDownloadCard();
            });

            // Progressive extraction: triggered as pieces download
            let lastExtractionAttemptBytes = 0;
            currentTorrent.on('download', (bytes) => {
                if (!currentTorrent || !currentTorrent.files || currentTorrent.files.length === 0) return;

                const mainFile = currentTorrent.files[0];
                const downloadedBytes = mainFile.downloaded || 0;
                const downloadedMB = downloadedBytes / (1024 * 1024);
                const extractionInterval = 5 * 1024 * 1024; // 5MB
                const enoughDataForFirstAttempt = downloadedBytes >= 512 * 1024; // 512KB

                if (enoughDataForFirstAttempt &&
                    (lastExtractionAttemptBytes === 0 || (downloadedBytes - lastExtractionAttemptBytes) >= extractionInterval)) {
                    lastExtractionAttemptBytes = downloadedBytes;
                    log(`üìö Attempting progressive extraction at ${downloadedMB.toFixed(1)} MB downloaded...`);
                    attemptProgressiveExtraction(mainFile, downloadedBytes);
                }
            });

            torrentStatsInterval = window.setInterval(() => {
                if (!currentTorrent) return;

                const speed = formatBytes(currentTorrent.downloadSpeed);
                const peers = currentTorrent.numPeers;

                // Calculate REAL progress from actual bytes
                const downloadedBytes = currentTorrent.downloaded;
                const totalBytes = currentTorrent.length;
                const realProgress = totalBytes > 0 ? Math.round((downloadedBytes / totalBytes) * 100) : 0;

                const downloaded = formatBytes(downloadedBytes);
                const totalSize = formatBytes(totalBytes);
                const uploaded = formatBytes(currentTorrent.uploaded);

                let statusMsg = '';
                if (realProgress === 0 && peers === 0) {
                    statusMsg = 'üîç Searching for peers... (check if torrent has seeders!)';
                } else if (realProgress < 100) {
                    statusMsg = `‚¨áÔ∏è ${realProgress}% ‚Ä¢ ${downloaded} / ${totalSize} ‚Ä¢ ${speed}/s ‚Ä¢ ${peers} peer${peers !== 1 ? 's' : ''}`;
                } else {
                    statusMsg = `‚úÖ Complete! ${totalSize} ‚Ä¢ Seeding to ${peers} peer${peers !== 1 ? 's' : ''} ‚Ä¢ ‚¨ÜÔ∏è ${uploaded}`;
                }
                updateDownloadStatus(statusMsg);

                // Update torrent metadata continuously as download progresses
                updateTorrentInfo(currentTorrent);
                refreshDownloadCard();
            }, 1000);

            currentTorrent.on('done', () => {
                if (torrentStatsInterval) {
                    clearInterval(torrentStatsInterval);
                    torrentStatsInterval = null;
                }
                updateDownloadStatus(`‚úÖ Download complete! ${catalogBooks.length.toLocaleString()} books ready to read`);
                showLibrary();
                refreshDownloadCard();
                disableProgressiveExtraction();
            });

            currentTorrent.on('error', (err) => {
                log(`‚ùå Error: ${err.message}`);
                console.error('Torrent error:', err);
                updateDownloadStatus(`‚ùå Error: ${err.message}`);
                refreshDownloadCard();
                if (torrentStatsInterval) {
                    clearInterval(torrentStatsInterval);
                    torrentStatsInterval = null;
                }
                disableProgressiveExtraction();
            });
        }

        function processLocalArchive(file) {
            updateStatus(`‚úÖ Local file loaded: ${catalogBooks.length.toLocaleString()} books ready to read`);
            showLibrary();
            activeDownload.magnet = null;
            refreshDownloadCard();
            updateDownloadStatus(`üìÅ Local archive loaded: ${file.name}`);
            updateTorrentInfo(null);
            refreshBrowserFilesystem(); // Show the loaded file in browser storage view
        }

        function refreshCatalogCard() {
            const summaryEl = document.getElementById('catalogSummary');
            updateDownloadedFilesView(currentTorrent);
            if (summaryEl) {
                summaryEl.textContent = catalogSummary.status;
            }
        }

        function updateDownloadedFilesView(torrent) {
            const container = document.getElementById('downloadedFiles');
            if (!container) return;

            if (!torrent || !torrent.files) {
                container.style.display = 'none';
                container.innerHTML = '';
                updateTorrentInfo(null);
                return;
            }

            if (torrent.files.length === 0) {
                container.style.display = '';
                container.innerHTML = '<div style="color:#999;">Torrent active, awaiting file list‚Ä¶</div>';
                updateTorrentInfo(torrent);
                return;
            }

            const files = torrent.files.map((file, index) => ({ file, index }))
                .sort((a, b) => a.file.path.localeCompare(b.file.path));

            const lines = files.map(({ file, index }) => {
                const percent = (file.progress * 100).toFixed(1);
                const downloaded = formatBytes(file.downloaded || 0);
                const total = formatBytes(file.length || 0);
                return `<div>${index + 1}. ${file.path || file.name || '(unnamed)'} ‚Äî ${percent}% (${downloaded} / ${total})</div>`;
            });

            container.innerHTML = lines.join('');
            container.style.display = lines.length ? '' : 'none';
            updateTorrentInfo(torrent);
        }

        function updateTorrentInfo(torrent) {
            const metadataSection = document.getElementById('torrentMetadataSection');
            const summaryEl = document.getElementById('torrentMetaSummary');
            const piecesEl = document.getElementById('torrentMetaPieces');
            const filesEl = document.getElementById('torrentMetaFiles');
            if (!summaryEl || !piecesEl || !filesEl) return;

            if (!torrent) {
                if (metadataSection) metadataSection.style.display = 'none';
                return;
            }

            // Show metadata section as soon as we have a torrent
            if (metadataSection) metadataSection.style.display = 'block';

            if (!torrent.length || !torrent.pieces || !torrent.pieces.length) {
                summaryEl.textContent = 'Torrent active, waiting for metadata‚Ä¶';
                piecesEl.innerHTML = '';
                filesEl.innerHTML = '';
                return;
            }

            const totalSize = formatBytes(torrent.length || 0);
            const pieceCount = torrent.pieces.length;
            const pieceSize = torrent.pieceLength ? formatBytes(torrent.pieceLength) : '‚Äî';
            const lastPieceSize = torrent.lastPieceLength ? formatBytes(torrent.lastPieceLength) : pieceSize;
            const downloadedBytes = torrent.downloaded || 0;
            const downloadedPercent = torrent.length ? ((downloadedBytes / torrent.length) * 100).toFixed(1) : '0.0';

            summaryEl.textContent = `Total ${totalSize} ‚Ä¢ Pieces ${pieceCount} √ó ${pieceSize} (last ${lastPieceSize}) ‚Ä¢ Downloaded ${formatBytes(downloadedBytes)} (${downloadedPercent}%)`;

            piecesEl.innerHTML = ``;

            const files = torrent.files ? torrent.files.slice().sort((a, b) => (a.path || a.name || '').localeCompare(b.path || b.name || '')) : [];
            const maxFiles = 10;
            filesEl.innerHTML = files.slice(0, maxFiles).map((file, idx) => {
                const name = file.path || file.name || `(file ${idx + 1})`;
                const size = formatBytes(file.length || 0);
                const pct = file.progress !== undefined ? (file.progress * 100).toFixed(1) : '0.0';
                return `<div>${idx + 1}. ${name} ‚Äî ${pct}% ‚Ä¢ ${size}</div>`;
            }).join('');

            if (files.length > maxFiles) {
                filesEl.innerHTML += `<div style="color:#777;">‚Ä¶ plus ${files.length - maxFiles} more files</div>`;
            }
        }

        function showLibrary() {
            const totalBooks = catalogBooks.length;
            const canReadBooks = isArchiveReady();

            if (totalBooks > 0) {
                if (canReadBooks) {
                    let statusText = `‚úÖ Catalog ready: ${totalBooks.toLocaleString()} books available to read`;
                    if (cachedBookCount > 0) {
                        statusText += ` ‚Ä¢ üíæ cached: ${cachedBookCount}`;
                    }
                    updateStatus(statusText);
                    catalogSummary.status = statusText;
                } else {
                    let statusText = `üìö Catalog loaded: ${totalBooks.toLocaleString()} books`;
                    if (cachedBookCount > 0) {
                        statusText += ` ‚Ä¢ üíæ cached: ${cachedBookCount}`;
                    }
                    updateStatus(statusText);
                    catalogSummary.status = statusText;
                }
            } else {
                catalogSummary.status = 'üìö Loading catalog‚Ä¶';
            }

            refreshCatalogCard();

            const searchBox = document.getElementById('searchBox');
            const bookList = document.getElementById('bookList');

            // Show first 50 books by default
            displayBooks(catalogBooks.slice(0, 50));

            // Setup search (only once)
            if (!searchBox.dataset.initialized) {
                searchBox.dataset.initialized = 'true';
                let searchTimeout;
                searchBox.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        const query = e.target.value.trim().toLowerCase();

                        if (query.length === 0) {
                            displayBooks(catalogBooks.slice(0, 50));
                            return;
                        }

                        if (query.length < 2) {
                            bookList.innerHTML = '';
                            return;
                        }

                        // Search books
                        const results = catalogBooks.filter(book =>
                            book.title.toLowerCase().includes(query) ||
                            book.author.toLowerCase().includes(query)
                        ).slice(0, 100);

                        displayBooks(results);
                    }, 300);
                });
            }
        }

        function displayBooks(books) {
            const bookList = document.getElementById('bookList');
            bookList.innerHTML = '';
            const archiveReady = isArchiveReady();
            const haveBooks = Array.isArray(books) && books.length > 0;
            currentDisplayedBooks = haveBooks ? books.slice() : [];

            if (!haveBooks) {
                const message = document.createElement('div');
                message.className = 'book-item';
                message.style.color = '#888';
                message.style.fontStyle = 'italic';
                message.textContent = archiveReady
                    ? 'No titles match this search.'
                    : 'Archive still loading. Try again after more blocks download.';
                bookList.appendChild(message);
                return;
            }

            if (!archiveReady) {
                const banner = document.createElement('div');
                banner.className = 'book-item';
                banner.style.color = '#666';
                banner.style.fontStyle = 'italic';
                banner.textContent = 'Download in progress ‚Äî cached titles show as üíæ and can be opened now.';
                bookList.appendChild(banner);
            }

            books.forEach((book) => {
                const row = document.createElement('div');
                row.className = 'book-item';

                const author = document.createElement('div');
                author.textContent = book.author;
                author.style.color = '#666';

                const title = document.createElement('div');
                if (book.cached) {
                    title.textContent = `üíæ ${book.title}`;
                    title.style.color = '#2e7d32';
                } else {
                    title.textContent = book.title;
                }

                const link = document.createElement('a');
                link.href = '#';
                link.textContent = book.cached ? '‚úì' : '‚Üí';
                if (book.cached) {
                    link.style.color = '#2e7d32';
                    link.style.fontWeight = 'bold';
                }
                link.onclick = (e) => {
                    e.preventDefault();
                    if (!isArchiveReady() && !book.cached) {
                        alert('Archive not ready yet. Finish download or load a local Gutenberg archive first.');
                        return;
                    }
                    openBookFromTorrent(book);
                };

                row.appendChild(author);
                row.appendChild(title);
                row.appendChild(link);
                bookList.appendChild(row);
            });
        }

        async function openBookFromTorrent(book) {
            log(`üìñ Opening "${book.title}"...`);

            try {
                // Check if book is already cached in memory from progressive extraction
                if (book.cached && book.content) {
                    log(`üíæ Loading from cache (no extraction needed)`);
                    displayBook(book, book.content);
                    return;
                }

                if (!isArchiveReady()) {
                    throw new Error('Archive not ready yet. Download must finish or a local file must be loaded.');
                }

                let arrayBuffer;
                let progress = 0;

                // Check if we're using local file or torrent
                if (localArchiveFile) {
                    log(`üìÅ Reading from local file: ${localArchiveFile.name}`);
                    arrayBuffer = await localArchiveFile.arrayBuffer();
                    progress = 100;
                } else if (currentTorrent && currentTorrent.files && currentTorrent.files.length > 0) {
                    // Get the .tar.gz file from WebTorrent
                    const file = currentTorrent.files[0];
                    progress = (file.progress * 100).toFixed(1);
                    log(`üì¶ Archive progress: ${progress}% (${formatBytes(file.downloaded)} / ${formatBytes(file.length)})`);

                    // Select this file with high priority to download needed pieces
                    file.select(0); // Highest priority

                    log(`üîç Reading from downloaded blocks...`);

                    // Try to get available data using streaming
                    const stream = file.createReadStream();
                    const chunks = [];
                    let totalBytes = 0;
                    const maxBytes = 500 * 1024 * 1024; // Read up to 500MB for extraction attempt

                    // Read available data
                    for await (const chunk of stream) {
                        chunks.push(chunk);
                        totalBytes += chunk.length;

                        if (totalBytes >= maxBytes || totalBytes >= file.downloaded) {
                            break;
                        }
                    }

                    log(`üì• Read ${formatBytes(totalBytes)} from available blocks`);

                    // Combine chunks
                    const combinedBuffer = new Uint8Array(totalBytes);
                    let offset = 0;
                    for (const chunk of chunks) {
                        combinedBuffer.set(chunk, offset);
                        offset += chunk.length;
                    }

                    arrayBuffer = combinedBuffer.buffer;
                } else {
                    throw new Error('No archive available');
                }

                log(`üîì Decompressing with gzip...`);
                let decompressed;
                try {
                    decompressed = pako.ungzip(new Uint8Array(arrayBuffer));
                } catch (e) {
                    // If gzip fails, try partial decompression
                    log(`‚ö†Ô∏è Partial gzip data, attempting extraction...`);
                    decompressed = pako.inflate(new Uint8Array(arrayBuffer), { raw: true });
                }

                log(`üìÇ Extracting books from tar archive...`);

                // Look for the book file - try common patterns
                const bookFileName = `pg${book.etextNo}.txt`;
                const possiblePaths = [
                    `cache/epub/${book.etextNo}/${bookFileName}`,
                    `${book.etextNo}/${bookFileName}`,
                    bookFileName
                ];

                log(`üîç Looking for: ${possiblePaths[0]}`);

                // Use js-untar to extract
                const files = await untar(decompressed.buffer);

                // Find the book file
                let bookFile = null;
                for (const path of possiblePaths) {
                    bookFile = files.find(f => f.name === path || f.name.endsWith(path));
                    if (bookFile) break;
                }

                if (!bookFile) {
                    // Try fuzzy match
                    bookFile = files.find(f => f.name.includes(`${book.etextNo}`) && f.name.endsWith('.txt'));
                }

                if (!bookFile) {
                    throw new Error(`Book not yet available in downloaded blocks. Try again as more downloads (currently ${progress}%)`);
                }

                log(`‚úÖ Found: ${bookFile.name}`);

                // Read the text content
                const textContent = new TextDecoder('utf-8').decode(bookFile.buffer);

                // Display the book
                book.cached = true;
                book.content = textContent;
                refreshCatalogCard();
                refreshCachedBookList();
                displayBook(book, textContent);

            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                console.error('Book opening error:', error);
                const downloadPct = (currentTorrent && currentTorrent.files && currentTorrent.files[0])
                    ? (currentTorrent.files[0].progress * 100).toFixed(1)
                    : '0';
                alert(`Could not extract book from available blocks (${downloadPct}% downloaded)\n\n${error.message}\n\nTry again as more data downloads, or wait until download is complete.`);
            }
        }

        function displayBook(book, content) {
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:#fff;z-index:1000;overflow-y:auto;padding:1rem';
            overlay.innerHTML = `<div style="max-width:700px;margin:0 auto;font-family:Georgia,serif;line-height:1.5">
<a href="#" onclick="this.parentElement.parentElement.remove();return false" style="font-size:1.5rem;text-decoration:none;color:#999">√ó</a>
<h3 style="margin:0.5rem 0">${book.title}</h3>
<small style="color:#666">${book.author}</small>
<hr style="margin:1rem 0;border:none;border-top:1px solid #ddd">
<pre style="white-space:pre-wrap;font-family:Georgia,serif;font-size:0.95rem">${content}</pre>
</div>`;
            document.body.appendChild(overlay);
            log(`‚úÖ Displaying "${book.title}"`);
        }

        window.startDownload = startDownload;
        window.handleTorrentFile = handleTorrentFile;
        window.loadLocalFile = loadLocalFile;
        window.refreshBrowserFilesystem = refreshBrowserFilesystem;
        window.handleSeedTorrentFile = handleSeedTorrentFile;
        window.handleSeedContentFile = handleSeedContentFile;
        window.startSeeding = startSeeding;

        log('‚úÖ Ready to download Gutenberg collection');
        log('üí° Click "Start Download" to begin');
    </script>
</body>
</html>
