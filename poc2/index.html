<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>poc2 – PeerJS file share</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      body {
        margin: 0;
        padding: 2rem;
        background: hsl(0 0% 96%);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      h1 {
        margin: 0;
        font-size: 1.8rem;
      }

      section {
        background: hsl(0 0% 100%);
        padding: 1.25rem;
        border-radius: 0.9rem;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.9rem;
      }

      label {
        font-weight: 600;
      }

      input[type="text"] {
        width: 100%;
        padding: 0.7rem;
        border-radius: 0.6rem;
        border: 1px solid hsl(215 16% 80%);
        font-size: 0.95rem;
        font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }

      input[type="file"] {
        font-size: 0.95rem;
      }

      button {
        padding: 0.65rem 1.4rem;
        border-radius: 0.6rem;
        border: none;
        font-size: 1rem;
        cursor: pointer;
        color: #fff;
        background: hsl(221 83% 53%);
        transition: background 0.2s ease;
      }

      button.secondary {
        background: hsl(215 19% 35%);
      }

      button:disabled {
        cursor: not-allowed;
        background: hsl(215 16% 70%);
      }

      .status {
        font-size: 0.95rem;
        color: hsl(221 83% 45%);
        min-height: 1.2rem;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .row > * {
        flex: 1 1 220px;
      }

      .fingerprint {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .color-box {
        width: 48px;
        height: 48px;
        border-radius: 0.5rem;
        border: 1px solid hsl(215 16% 80%);
        background: hsl(215 16% 70%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        color: hsl(215 19% 20%);
      }

      .fingerprint code {
        font-size: 0.85rem;
        word-break: break-all;
      }

      .received {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .received a {
        color: hsl(221 83% 45%);
        font-weight: 600;
      }
    </style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js" defer data-peerjs></script>
  </head>
  <body>
    <h1>PeerJS WebRTC file sender (poc2)</h1>

    <section aria-live="polite">
      <strong>Page fingerprint</strong>
      <div class="fingerprint">
        <div id="hashColor" class="color-box" role="img" aria-label="SHA-256 derived colour">--</div>
        <code id="pageHash">Computing SHA-256…</code>
      </div>
      <small>The colour changes whenever this HTML differs on fetch.</small>
    </section>

    <section>
      <strong>Peer status</strong>
      <div class="row">
        <div>
          <label for="remoteId">Remote Peer ID</label>
          <input id="remoteId" type="text" placeholder="Paste the remote peer ID">
        </div>
        <div style="align-self:flex-end">
          <button id="connectBtn">Connect</button>
          <button id="disconnectBtn" class="secondary" disabled>Disconnect</button>
        </div>
      </div>
      <div>
        <span>Share this page's Peer ID:</span>
        <code id="localId">Waiting for PeerJS…</code>
      </div>
      <div class="status" id="status">Initialising PeerJS…</div>
    </section>

    <section>
      <strong>Send a file</strong>
      <input id="fileInput" type="file" aria-label="Choose a file to send">
      <div class="row">
        <button id="sendBtn" disabled>Send file</button>
        <small>Both peers must keep this page open until the transfer finishes.</small>
      </div>
    </section>

    <section>
      <strong>Received files</strong>
      <div id="receivedList" class="received">
        <em>No files yet.</em>
      </div>
    </section>

    <script>
      const statusEl = document.getElementById('status');
      const localIdEl = document.getElementById('localId');
      const remoteIdEl = document.getElementById('remoteId');
      const connectBtn = document.getElementById('connectBtn');
      const disconnectBtn = document.getElementById('disconnectBtn');
      const fileInput = document.getElementById('fileInput');
      const sendBtn = document.getElementById('sendBtn');
      const receivedList = document.getElementById('receivedList');
      const pageHashEl = document.getElementById('pageHash');
      const hashColorEl = document.getElementById('hashColor');

      let peer;
      let conn;

      const setStatus = (message) => {
        statusEl.textContent = message;
      };

      const resetReceivedList = () => {
        receivedList.innerHTML = '';
        const placeholder = document.createElement('em');
        placeholder.textContent = 'No files yet.';
        receivedList.appendChild(placeholder);
      };

      const appendReceivedFile = (name, blob) => {
        if (receivedList.firstElementChild && receivedList.firstElementChild.tagName === 'EM') {
          receivedList.innerHTML = '';
        }
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = name;
        link.textContent = `Download ${name} (${Math.round(blob.size / 1024)} KB)`;
        receivedList.appendChild(link);
      };

      const wireConnection = (connection, origin) => {
        if (conn && conn !== connection) {
          conn.close();
        }

        conn = connection;

        conn.once('open', () => {
          setStatus(`Connected to ${conn.peer} (${origin})`);
          sendBtn.disabled = false;
          disconnectBtn.disabled = false;
        });

        conn.on('data', (payload) => {
          if (payload && payload.kind === 'file' && Array.isArray(payload.bytes)) {
            const bytes = new Uint8Array(payload.bytes);
            const blob = new Blob([bytes], { type: payload.mime || 'application/octet-stream' });
            appendReceivedFile(payload.name || 'received.bin', blob);
            setStatus(`File received from ${conn.peer}`);
          } else {
            console.log('Received non-file payload:', payload);
          }
        });

        conn.on('close', () => {
          setStatus(`Connection to ${conn.peer} closed.`);
          sendBtn.disabled = true;
          disconnectBtn.disabled = true;
        });

        conn.on('error', (err) => {
          console.error('Connection error:', err);
          setStatus(`Connection error: ${err.message}`);
        });
      };

      const initialisePeer = () => {
        peer = new window.Peer();

        peer.on('open', (id) => {
          localIdEl.textContent = id;
          localIdEl.title = 'Share this ID with the remote peer';
          setStatus('Share your Peer ID with a partner, then connect either way.');
        });

        peer.on('error', (err) => {
          console.error('Peer error:', err);
          setStatus(`Peer error: ${err.type ?? err.message}`);
        });

        peer.on('connection', (incomingConn) => {
          setStatus(`Incoming connection from ${incomingConn.peer}`);
          wireConnection(incomingConn, 'incoming');
        });
      };

      connectBtn.addEventListener('click', () => {
        const remoteId = remoteIdEl.value.trim();
        if (!remoteId) {
          setStatus('Enter a remote peer ID first.');
          return;
        }

        if (!peer || peer.disconnected) {
          setStatus('PeerJS still initialising. Please wait.');
          return;
        }

        setStatus(`Connecting to ${remoteId}…`);
        const outgoing = peer.connect(remoteId, { reliable: true });
        wireConnection(outgoing, 'outgoing');
      });

      disconnectBtn.addEventListener('click', () => {
        if (conn) {
          conn.close();
        }
        sendBtn.disabled = true;
        disconnectBtn.disabled = true;
        setStatus('Disconnected.');
      });

      sendBtn.addEventListener('click', () => {
        const file = fileInput.files?.[0];
        if (!conn || conn.open !== true) {
          setStatus('Connect to a peer before sending files.');
          return;
        }
        if (!file) {
          setStatus('Choose a file to send.');
          return;
        }

        const reader = new FileReader();
        reader.onload = () => {
          const arrayBuffer = reader.result;
          const bytes = new Uint8Array(arrayBuffer);
          const payload = {
            kind: 'file',
            name: file.name,
            mime: file.type || 'application/octet-stream',
            size: file.size,
            bytes: Array.from(bytes),
          };

          setStatus(`Sending ${file.name} (${Math.round(file.size / 1024)} KB)…`);
          conn.send(payload);
          setStatus(`Sent ${file.name}.`);
        };

        reader.onerror = () => {
          console.error('FileReader error:', reader.error);
          setStatus(`Failed to read file: ${reader.error?.message ?? 'unknown error'}`);
        };

        reader.readAsArrayBuffer(file);
      });

      const updatePageFingerprint = async () => {
        if (!window.crypto?.subtle) {
          pageHashEl.textContent = 'Web Crypto unsupported.';
          hashColorEl.textContent = 'X';
          return;
        }

        try {
          const response = await fetch(window.location.href, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const text = await response.text();
          const encoder = new TextEncoder();
          const data = encoder.encode(text);
          const digest = await crypto.subtle.digest('SHA-256', data);
          const hashBytes = new Uint8Array(digest);
          const hashHex = Array.from(hashBytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
          pageHashEl.textContent = hashHex;

          const [r, g, b] = hashBytes;
          hashColorEl.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
          hashColorEl.textContent = '';
          hashColorEl.title = `SHA-256: ${hashHex}`;
          hashColorEl.setAttribute('aria-label', `Page hash colour ${hashHex.slice(0, 6)}`);
        } catch (err) {
          console.error('Fingerprint error:', err);
          pageHashEl.textContent = `Fingerprint unavailable (${err.message}).`;
          hashColorEl.style.backgroundColor = '#9ca3af';
          hashColorEl.textContent = '!';
          hashColorEl.title = 'Fingerprint unavailable';
          hashColorEl.setAttribute('aria-label', 'Fingerprint unavailable');
        }
      };

      const ensurePeerReady = () => new Promise((resolve, reject) => {
        if (window.Peer) {
          resolve(window.Peer);
          return;
        }
        const script = document.querySelector('script[data-peerjs]');
        if (!script) {
          reject(new Error('PeerJS script tag missing.'));
          return;
        }
        script.addEventListener('load', () => {
          if (window.Peer) {
            resolve(window.Peer);
          } else {
            reject(new Error('PeerJS loaded but global not found.'));
          }
        }, { once: true });
        script.addEventListener('error', () => reject(new Error('PeerJS failed to load.')), { once: true });
      });

      updatePageFingerprint();
      resetReceivedList();

      ensurePeerReady()
        .then(() => {
          initialisePeer();
        })
        .catch((err) => {
          console.error(err);
          setStatus(err.message);
          localIdEl.textContent = 'Unavailable';
          localIdEl.title = err.message;
        });
    </script>
  </body>
</html>
