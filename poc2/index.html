<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>poc2 – libp2p WebRTC PNG sender</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      body {
        margin: 0;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        background: #f5f5f5;
      }

      h1 {
        margin: 0;
        font-size: 1.8rem;
      }

      section {
        background: #ffffff;
        padding: 1rem;
        border-radius: 0.75rem;
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      textarea,
      input[type="text"] {
        width: 100%;
        font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.9rem;
        padding: 0.75rem;
        border-radius: 0.5rem;
        border: 1px solid #d0d0d0;
        min-height: 3.5rem;
      }

      button {
        padding: 0.6rem 1.2rem;
        font-size: 1rem;
        border-radius: 0.5rem;
        border: none;
        cursor: pointer;
        color: #fff;
        background: #2563eb;
        transition: background 0.2s ease;
      }

      button.secondary {
        background: #4b5563;
      }

      button:disabled {
        background: #9ca3af;
        cursor: not-allowed;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .row button {
        flex: 1 1 200px;
      }

      img {
        max-width: 100%;
        border-radius: 0.5rem;
        border: 1px solid #d1d5db;
      }

      .status {
        font-size: 0.95rem;
        color: #2563eb;
        min-height: 1.2rem;
      }
    </style>
  </head>
  <body>
    <h1>WebRTC PNG demo (poc2)</h1>

    <section>
      <strong>Share these multiaddrs with the remote browser:</strong>
      <textarea id="multiaddrs" readonly>Starting libp2p node…</textarea>
      <div class="status" id="status">Bootstrapping…</div>
    </section>

    <section>
      <label for="remoteAddr"><strong>Remote peer multiaddr</strong></label>
      <input id="remoteAddr" type="text" placeholder="/webrtc/certhash/.../p2p/..." autocomplete="off" />

      <div class="row">
        <button id="receiveBtn" class="secondary" type="button">Ready to receive</button>
        <button id="sendBtn" type="button">Send timestamp PNG</button>
      </div>
    </section>

    <section>
      <strong>Last image sent</strong>
      <img id="sentPreview" alt="Preview of the last PNG you sent" />
    </section>

    <section>
      <strong>Last image received</strong>
      <img id="receivedPreview" alt="Preview of the last PNG you received" />
    </section>

    <script type="module">
      import { createLibp2p } from 'https://esm.sh/libp2p@3.0.7';
      import { webRTC } from 'https://esm.sh/@libp2p/webrtc@5.0.8';
      import { noise } from 'https://esm.sh/@chainsafe/libp2p-noise@15.1.0';
      import { yamux } from 'https://esm.sh/@chainsafe/libp2p-yamux@3.0.4';

      const PROTOCOL = '/poc2/png/1.0.0';

      const statusEl = document.getElementById('status');
      const multiaddrsEl = document.getElementById('multiaddrs');
      const remoteAddrEl = document.getElementById('remoteAddr');
      const sendBtn = document.getElementById('sendBtn');
      const receiveBtn = document.getElementById('receiveBtn');
      const sentPreview = document.getElementById('sentPreview');
      const receivedPreview = document.getElementById('receivedPreview');

      const setStatus = (msg) => {
        console.info(msg);
        statusEl.textContent = msg;
      };

      const getLibp2pNode = async () => {
        setStatus('Initializing libp2p node…');
        const node = await createLibp2p({
          transports: [
            webRTC({
              rtcConfiguration: {
                iceServers: [
                  { urls: 'stun:stun.l.google.com:19302' }
                ]
              }
            })
          ],
          connectionEncryption: [noise()],
          streamMuxers: [yamux()],
          addresses: {
            listen: ['/webrtc']
          }
        });

        node.addEventListener('peer:connect', (evt) => {
          setStatus(`Connected to peer ${evt.detail.remotePeer.toString()}`);
        });

        await node.start();
        setStatus('libp2p ready. Share your multiaddrs to connect.');
        multiaddrsEl.value = node.getMultiaddrs().map((addr) => addr.toString()).join('\n') || 'No multiaddrs available.';
        return node;
      };

      const readAll = async (source) => {
        const chunks = [];
        for await (const chunk of source) {
          if (chunk instanceof Uint8Array) {
            chunks.push(chunk);
          } else if (Array.isArray(chunk)) {
            chunks.push(Uint8Array.from(chunk));
          } else {
            chunks.push(new Uint8Array(chunk));
          }
        }
        const total = chunks.reduce((size, chunk) => size + chunk.length, 0);
        const merged = new Uint8Array(total);
        let offset = 0;
        for (const chunk of chunks) {
          merged.set(chunk, offset);
          offset += chunk.length;
        }
        return merged;
      };

      const streamWriter = async (stream, bytes) => {
        async function* singleChunk() {
          yield bytes;
        }
        await stream.sink(singleChunk());
      };

      const generatePngBytes = () => new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.width = 480;
        canvas.height = 240;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          reject(new Error('Canvas not supported in this browser.'));
          return;
        }

        const time = new Date();
        const timestamp = time.toLocaleString();
        const hue = Math.floor(Math.random() * 360);

        // Background
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, `hsl(${hue}, 70%, 60%)`);
        gradient.addColorStop(1, `hsl(${(hue + 60) % 360}, 70%, 40%)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Timestamp overlay
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(20, canvas.height - 80, canvas.width - 40, 60);
        ctx.fillStyle = '#111827';
        ctx.font = '20px "Fira Code", "Menlo", monospace';
        ctx.fillText('Random PNG @', 30, canvas.height - 50);
        ctx.font = '24px "Fira Code", "Menlo", monospace';
        ctx.fillText(timestamp, 30, canvas.height - 20);

        canvas.toBlob(async (blob) => {
          if (!blob) {
            reject(new Error('Failed to create PNG blob.'));
            return;
          }
          const arrayBuffer = await blob.arrayBuffer();
          resolve({ bytes: new Uint8Array(arrayBuffer), blob });
        }, 'image/png');
      });

      let node;
      let readyToReceive = false;

      receiveBtn.addEventListener('click', () => {
        readyToReceive = true;
        setStatus('Armed to receive the next image.');
        receiveBtn.disabled = true;
        setTimeout(() => {
          receiveBtn.disabled = false;
        }, 1500);
      });

      const initNode = async () => {
        node = await getLibp2pNode();

        node.handle(PROTOCOL, async ({ stream }) => {
          setStatus('Incoming image stream…');
          const bytes = await readAll(stream.source);
          if (!readyToReceive) {
            setStatus('Received image but receive button was not pressed. Displaying anyway.');
          } else {
            readyToReceive = false;
            setStatus('Image received and displayed.');
          }
          const blob = new Blob([bytes], { type: 'image/png' });
          const url = URL.createObjectURL(blob);
          receivedPreview.src = url;
        });
      };

      sendBtn.addEventListener('click', async () => {
        if (!node) {
          setStatus('Waiting for libp2p to finish starting…');
          return;
        }

        const remoteAddr = remoteAddrEl.value.trim();
        if (!remoteAddr) {
          setStatus('Enter a remote peer multiaddr first.');
          return;
        }

        try {
          sendBtn.disabled = true;
          setStatus('Generating PNG…');
          const { bytes, blob } = await generatePngBytes();
          sentPreview.src = URL.createObjectURL(blob);

          setStatus(`Dialing ${remoteAddr}…`);
          const stream = await node.dialProtocol(remoteAddr, PROTOCOL);

          setStatus('Sending PNG bytes over WebRTC data channel…');
          await streamWriter(stream, bytes);
          setStatus('PNG sent!');
        } catch (err) {
          console.error(err);
          setStatus(`Send failed: ${err.message}`);
        } finally {
          sendBtn.disabled = false;
        }
      });

      initNode().catch((err) => {
        console.error(err);
        setStatus(`Failed to start libp2p: ${err.message}`);
        multiaddrsEl.value = 'Unable to start libp2p node. See console for details.';
        sendBtn.disabled = true;
        receiveBtn.disabled = true;
      });
    </script>
  </body>
</html>
