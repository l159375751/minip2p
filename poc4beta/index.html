<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>poc4beta â€“ PeerJS with WebRTC Debug Logging</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      body {
        margin: 0;
        padding: 2rem;
        background: hsl(0 0% 96%);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      h1 {
        margin: 0;
        font-size: 1.8rem;
      }

      section {
        background: hsl(0 0% 100%);
        padding: 1.25rem;
        border-radius: 0.9rem;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.9rem;
      }

      label {
        font-weight: 600;
      }

      input[type="text"] {
        width: 100%;
        padding: 0.7rem;
        border-radius: 0.6rem;
        border: 1px solid hsl(215 16% 80%);
        font-size: 0.95rem;
        font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }

      input[type="file"] {
        font-size: 0.95rem;
      }

      button {
        padding: 0.65rem 1.4rem;
        border-radius: 0.6rem;
        border: none;
        font-size: 1rem;
        cursor: pointer;
        color: #fff;
        background: hsl(221 83% 53%);
        transition: background 0.2s ease;
      }

      button.secondary {
        background: hsl(215 19% 35%);
      }

      button:disabled {
        cursor: not-allowed;
        background: hsl(215 16% 70%);
      }

      .status {
        font-size: 0.95rem;
        color: hsl(221 83% 45%);
        min-height: 1.2rem;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .row > * {
        flex: 1 1 220px;
      }

      .id-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
      }

      .id-row code {
        padding: 0.35rem 0.5rem;
        background: hsl(215 16% 92%);
        border-radius: 0.4rem;
      }

      .icon-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.4rem;
        width: 2.25rem;
        height: 2.25rem;
      }

      .icon-button span {
        font-size: 1.05rem;
        line-height: 1;
      }

      .fingerprint-inline {
        display: inline-flex;
        align-items: center;
        margin-left: 0.75rem;
      }

      .color-dot {
        display: inline-block;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 1px solid hsl(215 16% 75%);
        background: hsl(215 16% 92%);
      }

      .received {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .received a {
        color: hsl(221 83% 45%);
        font-weight: 600;
      }

      .received-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .swatch {
        width: 40px;
        height: 40px;
        border-radius: 0.5rem;
        border: 1px solid hsl(215 16% 70%);
        display: inline-block;
        background: hsl(215 16% 92%);
      }

      .received-item .swatch {
        width: 24px;
        height: 24px;
      }

      .received-item small {
        font-size: 0.8rem;
        color: hsl(215 19% 35%);
        font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }

      .source-card {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding: 1rem;
        border: 1px solid hsl(215 16% 88%);
        border-radius: 0.75rem;
        background: hsl(215 40% 97%);
      }

      .source-option {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        font-weight: 600;
      }

      .source-option label {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }

      .source-option button {
        margin-left: auto;
      }

      .demo-controls {
        display: flex;
        gap: 0.5rem;
        margin-left: auto;
      }

      .demo-controls > button {
        flex: 0 1 auto;
      }

      .source-option input[type="radio"] {
        transform: scale(1.1);
        accent-color: hsl(221 83% 53%);
      }

      .demo-preview {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }

      .demo-thumb {
        flex: 0 0 240px;
        border-radius: 0.75rem;
        border: 1px solid hsl(215 16% 80%);
        background: hsl(215 30% 90%);
        overflow: hidden;
      }

      .demo-thumb img {
        display: block;
        width: 100%;
        height: auto;
      }

      .demo-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        align-items: center;
      }

      .demo-meta code {
        font-size: 0.85rem;
        word-break: break-all;
      }

      .send-note {
        display: block;
        margin-top: 0.75rem;
        color: hsl(215 19% 35%);
      }

      .debug-notice {
        padding: 1rem;
        background: hsl(142 76% 92%);
        border-left: 4px solid hsl(142 76% 36%);
        border-radius: 0.5rem;
        font-size: 0.9rem;
        color: hsl(142 76% 20%);
      }

      .debug-notice strong {
        display: block;
        margin-bottom: 0.5rem;
      }
    </style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js" defer data-peerjs></script>
  </head>
  <body>
    <h1>PeerJS WebRTC with Debug Logging (poc4beta)
      <span class="fingerprint-inline">
        <span id="hashColor" class="color-dot" aria-label="Page hash colour">&nbsp;</span>
      </span>
    </h1>

    <div class="debug-notice">
      <strong>WebRTC Debug Mode Active</strong>
      Open your browser console (Ctrl+Shift+I) to see detailed WebRTC logging including ICE candidates, connection states, STUN/TURN info, and SDP offers/answers.
    </div>

    <section>
      <strong>Peer status</strong>
      <div class="row">
        <div>
          <label for="remoteId">Remote Peer ID</label>
          <input id="remoteId" type="text" placeholder="Paste the remote peer ID">
        </div>
        <div style="align-self:flex-end">
          <button id="connectBtn">Connect</button>
        </div>
      </div>
      <div class="id-row">
        <span>Share this page's Peer ID:</span>
        <code id="localId">Waiting for PeerJSâ€¦</code>
        <button id="copyIdBtn" class="secondary icon-button" type="button" aria-label="Copy peer ID" title="Copy peer ID" disabled>
          <span aria-hidden="true">ðŸ“‹</span>
        </button>
      </div>
      <div class="status" id="status">Initialising PeerJSâ€¦</div>
    </section>

    <section>
      <strong>Send a file or share the hash-colour demo</strong>
      <p>The demo timestamp image is selected by default and includes its SHA-256 hash plus a colour swatch derived from that hash. Switch to upload mode if you prefer to send your own file.</p>
      <div class="source-card">
        <div class="source-option">
          <label>
            <input type="radio" name="sendSource" value="demo" checked>
            Demo timestamp PNG (default)
          </label>
          <div class="demo-controls">
            <button id="generateDemoBtn" type="button" class="secondary">Regenerate</button>
            <button id="sendBtn" disabled>Send selected</button>
          </div>
        </div>
        <div class="demo-preview">
          <div class="demo-thumb">
            <img id="demoPreviewImage" alt="Demo PNG preview" hidden>
          </div>
          <div class="demo-meta">
            <small id="demoPreviewHash">Preparing hashâ€¦</small>
          </div>
        </div>
      </div>
      <div class="source-card">
        <div class="source-option">
          <label>
            <input type="radio" name="sendSource" value="file">
            Upload a custom file
          </label>
        </div>
        <input id="fileInput" type="file" aria-label="Choose a file to send">
      </div>
      <small class="send-note">Keep this page open until the transfer finishes.</small>
    </section>

    <section>
      <strong>Received files</strong>
      <div id="receivedList" class="received">
        <em>No files yet.</em>
      </div>
    </section>

    <script>
      console.log('%cðŸš€ POC4BETA WebRTC Debug Mode Started', 'background: #2563eb; color: white; font-size: 14px; font-weight: bold; padding: 4px 8px; border-radius: 4px;');
      console.log('All WebRTC events, ICE candidates, STUN/TURN info, and SDP details will be logged below.');

      const statusEl = document.getElementById('status');
      const localIdEl = document.getElementById('localId');
      const remoteIdEl = document.getElementById('remoteId');
      const connectBtn = document.getElementById('connectBtn');
      const fileInput = document.getElementById('fileInput');
      const sendBtn = document.getElementById('sendBtn');
      const receivedList = document.getElementById('receivedList');
      const pageHashEl = document.createElement('span');
      pageHashEl.id = 'pageHash';
      pageHashEl.hidden = true;
      document.body.appendChild(pageHashEl);
      const hashColorEl = document.getElementById('hashColor');
      const copyIdBtn = document.getElementById('copyIdBtn');
      const generateDemoBtn = document.getElementById('generateDemoBtn');
      const sourceRadios = document.querySelectorAll('input[name="sendSource"]');
      const demoPreviewImage = document.getElementById('demoPreviewImage');
      const demoPreviewHash = document.getElementById('demoPreviewHash');

      let peer;
      let conn;
      let latestDemo = null;
      let demoUrl = null;

      if (connectBtn) connectBtn.disabled = true;

      const toHex = (value) => value.toString(16).padStart(2, '0');
      const rgbToHex = ([r, g, b]) => `#${toHex(r)}${toHex(g)}${toHex(b)}`;

      const getSelectedSource = () => {
        const selected = Array.from(sourceRadios).find((radio) => radio.checked);
        return selected ? selected.value : 'demo';
      };

      const isConnected = () => Boolean(conn && conn.open === true);

      const updateSendButtonState = () => {
        if (!isConnected()) {
          sendBtn.disabled = true;
          return;
        }

        if (getSelectedSource() === 'demo') {
          sendBtn.disabled = !latestDemo;
        } else {
          const hasFile = fileInput.files && fileInput.files.length > 0;
          sendBtn.disabled = !hasFile;
        }
      };

      const setStatus = (message) => {
        statusEl.textContent = message;
      };

      const resetReceivedList = () => {
        receivedList.innerHTML = '';
        const placeholder = document.createElement('em');
        placeholder.textContent = 'No files yet.';
        receivedList.appendChild(placeholder);
      };

      const appendReceivedFile = (name, blob, meta = {}) => {
        if (receivedList.firstElementChild && receivedList.firstElementChild.tagName === 'EM') {
          receivedList.innerHTML = '';
        }

        const wrapper = document.createElement('div');
        wrapper.className = 'received-item';
        const hashValueRaw = meta.hashHex || meta.hash || null;
        const hashValue = hashValueRaw ? String(hashValueRaw) : null;

        if (meta.colorHex) {
          const swatch = document.createElement('span');
          swatch.className = 'swatch';
          swatch.style.backgroundColor = meta.colorHex;
          swatch.title = hashValue ? `Colour derived from hash ${hashValue}` : 'Colour derived from hash';
          wrapper.appendChild(swatch);
        }

        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = name;
        link.textContent = `Download ${name} (${Math.round(blob.size / 1024)} KB)`;
        if (hashValue) {
          link.title = `SHA-256 ${hashValue}`;
        }

        wrapper.appendChild(link);

        if (hashValue) {
          const info = document.createElement('small');
          info.textContent = `hash ${hashValue.slice(0, 12)}â€¦`;
          info.title = hashValue;
          wrapper.appendChild(info);
        }

        receivedList.appendChild(wrapper);
      };

      // Enhanced WebRTC debugging wrapper for connections
      const wrapConnectionWithDebug = (connection, label) => {
        console.group(`%cðŸ”Œ ${label} Connection Wrapper`, 'color: #8b5cf6; font-weight: bold;');
        console.log('Peer ID:', connection.peer);
        console.log('Connection ID:', connection.connectionId);
        console.log('Connection metadata:', connection.metadata);
        console.groupEnd();

        // Access the underlying PeerConnection if available
        const getPeerConnection = () => {
          // PeerJS stores the RTCPeerConnection in the peerConnection property
          return connection.peerConnection || connection._pc;
        };

        // Set up interval to log connection state
        const stateCheckInterval = setInterval(() => {
          const pc = getPeerConnection();
          if (pc) {
            console.log(`%cðŸ“Š ${label} Connection State Update`, 'color: #06b6d4; font-weight: bold;', {
              connectionState: pc.connectionState,
              iceConnectionState: pc.iceConnectionState,
              iceGatheringState: pc.iceGatheringState,
              signalingState: pc.signalingState,
            });
          }
        }, 5000);

        // Monitor the underlying RTCPeerConnection
        setTimeout(() => {
          const pc = getPeerConnection();
          if (!pc) {
            console.warn(`%câš ï¸ ${label} RTCPeerConnection not accessible yet`, 'color: #f59e0b;');
            return;
          }

          console.group(`%cðŸŽ¯ ${label} RTCPeerConnection Found`, 'color: #10b981; font-weight: bold;');
          console.log('RTCPeerConnection object:', pc);
          console.log('Connection state:', pc.connectionState);
          console.log('ICE connection state:', pc.iceConnectionState);
          console.log('ICE gathering state:', pc.iceGatheringState);
          console.log('Signaling state:', pc.signalingState);
          console.groupEnd();

          // ICE candidate event
          pc.addEventListener('icecandidate', (event) => {
            if (event.candidate) {
              console.group(`%cðŸ§Š ${label} ICE Candidate`, 'color: #3b82f6; font-weight: bold;');
              console.log('Candidate:', event.candidate.candidate);
              console.log('Type:', event.candidate.type);
              console.log('Protocol:', event.candidate.protocol);
              console.log('Address:', event.candidate.address);
              console.log('Port:', event.candidate.port);
              console.log('Priority:', event.candidate.priority);
              console.log('Foundation:', event.candidate.foundation);
              console.log('Component:', event.candidate.component);
              console.log('Related address:', event.candidate.relatedAddress);
              console.log('Related port:', event.candidate.relatedPort);
              console.log('Full candidate object:', event.candidate);
              console.groupEnd();
            } else {
              console.log(`%câœ… ${label} ICE Candidate Gathering Complete`, 'color: #10b981; font-weight: bold;');
            }
          });

          // ICE connection state change
          pc.addEventListener('iceconnectionstatechange', () => {
            console.log(`%cðŸ”„ ${label} ICE Connection State:`, 'color: #8b5cf6; font-weight: bold;', pc.iceConnectionState);
          });

          // ICE gathering state change
          pc.addEventListener('icegatheringstatechange', () => {
            console.log(`%cðŸ“¡ ${label} ICE Gathering State:`, 'color: #06b6d4; font-weight: bold;', pc.iceGatheringState);
          });

          // Connection state change
          pc.addEventListener('connectionstatechange', () => {
            console.log(`%cðŸ”— ${label} Connection State:`, 'color: #f59e0b; font-weight: bold;', pc.connectionState);
          });

          // Signaling state change
          pc.addEventListener('signalingstatechange', () => {
            console.log(`%cðŸ“ž ${label} Signaling State:`, 'color: #ec4899; font-weight: bold;', pc.signalingState);
          });

          // Track event
          pc.addEventListener('track', (event) => {
            console.group(`%cðŸŽ¬ ${label} Track Received`, 'color: #10b981; font-weight: bold;');
            console.log('Track:', event.track);
            console.log('Streams:', event.streams);
            console.groupEnd();
          });

          // Data channel event
          pc.addEventListener('datachannel', (event) => {
            console.group(`%cðŸ’¬ ${label} Data Channel`, 'color: #8b5cf6; font-weight: bold;');
            console.log('Channel label:', event.channel.label);
            console.log('Channel ID:', event.channel.id);
            console.log('Channel protocol:', event.channel.protocol);
            console.log('Channel state:', event.channel.readyState);
            console.groupEnd();
          });

          // Negotiation needed
          pc.addEventListener('negotiationneeded', () => {
            console.log(`%cðŸ”„ ${label} Negotiation Needed`, 'color: #f59e0b; font-weight: bold;');
          });

          // Log local description (SDP)
          if (pc.localDescription) {
            console.group(`%cðŸ“ ${label} Local SDP (Offer/Answer)`, 'color: #3b82f6; font-weight: bold;');
            console.log('Type:', pc.localDescription.type);
            console.log('SDP:', pc.localDescription.sdp);
            console.groupEnd();
          }

          // Log remote description (SDP)
          if (pc.remoteDescription) {
            console.group(`%cðŸ“¥ ${label} Remote SDP (Offer/Answer)`, 'color: #8b5cf6; font-weight: bold;');
            console.log('Type:', pc.remoteDescription.type);
            console.log('SDP:', pc.remoteDescription.sdp);
            console.groupEnd();
          }

          // Monitor for SDP changes
          const originalSetLocalDescription = pc.setLocalDescription.bind(pc);
          pc.setLocalDescription = async function(description) {
            console.group(`%cðŸ“¤ ${label} Setting Local Description`, 'color: #3b82f6; font-weight: bold;');
            console.log('Type:', description?.type);
            console.log('SDP:', description?.sdp);
            console.groupEnd();
            return originalSetLocalDescription(description);
          };

          const originalSetRemoteDescription = pc.setRemoteDescription.bind(pc);
          pc.setRemoteDescription = async function(description) {
            console.group(`%cðŸ“¨ ${label} Setting Remote Description`, 'color: #8b5cf6; font-weight: bold;');
            console.log('Type:', description?.type);
            console.log('SDP:', description?.sdp);
            console.groupEnd();
            return originalSetRemoteDescription(description);
          };

          // Log ICE servers configuration
          const config = pc.getConfiguration();
          if (config.iceServers) {
            console.group(`%cðŸŒ ${label} ICE Servers (STUN/TURN)`, 'color: #10b981; font-weight: bold;');
            config.iceServers.forEach((server, index) => {
              console.log(`Server ${index + 1}:`, {
                urls: server.urls,
                username: server.username || '(none)',
                credential: server.credential ? '(present)' : '(none)',
              });
            });
            console.groupEnd();
          }

          // Periodically log stats
          const statsInterval = setInterval(async () => {
            if (pc.connectionState === 'closed') {
              clearInterval(statsInterval);
              clearInterval(stateCheckInterval);
              return;
            }

            try {
              const stats = await pc.getStats();
              console.group(`%cðŸ“Š ${label} WebRTC Stats`, 'color: #06b6d4; font-weight: bold;');
              stats.forEach((report) => {
                if (report.type === 'candidate-pair' && report.nominated) {
                  console.log('Active candidate pair:', report);
                } else if (report.type === 'local-candidate' || report.type === 'remote-candidate') {
                  console.log(`${report.type}:`, {
                    candidateType: report.candidateType,
                    protocol: report.protocol,
                    address: report.address || report.ip,
                    port: report.port,
                    priority: report.priority,
                  });
                } else if (report.type === 'inbound-rtp' || report.type === 'outbound-rtp') {
                  console.log(`${report.type}:`, {
                    mediaType: report.mediaType,
                    bytesReceived: report.bytesReceived,
                    bytesSent: report.bytesSent,
                    packetsReceived: report.packetsReceived,
                    packetsSent: report.packetsSent,
                  });
                }
              });
              console.groupEnd();
            } catch (err) {
              console.error(`Error getting stats for ${label}:`, err);
            }
          }, 10000);

        }, 100);
      };

      const wireConnection = (connection, origin) => {
        if (conn && conn !== connection) {
          conn.close();
        }

        conn = connection;
        updateSendButtonState();

        // Enable WebRTC debugging for this connection
        wrapConnectionWithDebug(connection, origin.toUpperCase());

        let incomingMeta = null;

        const processIncomingBuffer = (buffer) => {
          const peerId = connection.peer;
          const meta = incomingMeta || {};
          incomingMeta = null;
          const blob = new Blob([buffer], { type: meta.mime || 'application/octet-stream' });
          const fileName = meta.name || `received-${Date.now()}.bin`;
          appendReceivedFile(fileName, blob, meta);
          const hashLabel = meta.hashHex || meta.hash;
          const statusBase = `Received ${fileName} from ${peerId}`;
          if (hashLabel) {
            setStatus(`${statusBase} (hash ${hashLabel.slice(0, 12)}â€¦).`);
          } else {
            setStatus(statusBase);
          }
          console.log(`%câœ… File Received: ${fileName}`, 'color: #10b981; font-weight: bold;', {
            size: `${Math.round(blob.size / 1024)} KB`,
            hash: hashLabel,
          });
        };

        const handleOpen = () => {
          setStatus(`Connected to ${connection.peer} (${origin})`);
          updateSendButtonState();
          console.log(`%câœ… Connection Open: ${origin}`, 'color: #10b981; font-weight: bold;', connection.peer);
        };

        if (conn.open) {
          handleOpen();
        } else {
          conn.once('open', handleOpen);
        }

        conn.on('data', async (payload) => {
          const peerId = connection.peer;
          console.log(`%cðŸ“¥ Data Received from ${peerId}`, 'color: #3b82f6; font-weight: bold;', typeof payload, payload);

          if (payload && typeof payload === 'object' && payload.kind === 'file-meta') {
            incomingMeta = payload;
            console.log('%cðŸ“‹ File Metadata Received', 'color: #8b5cf6; font-weight: bold;', payload);
            return;
          }

          if (payload instanceof ArrayBuffer) {
            processIncomingBuffer(payload);
            return;
          }

          if (payload instanceof Blob) {
            const buffer = await payload.arrayBuffer();
            processIncomingBuffer(buffer);
            return;
          }

          if (payload?.byteLength && payload.buffer instanceof ArrayBuffer) {
            const buffer = payload.buffer.slice(payload.byteOffset, payload.byteOffset + payload.byteLength);
            processIncomingBuffer(buffer);
            return;
          }

          console.log('Received non-file payload:', payload);
        });

        conn.on('close', () => {
          const peerId = connection.peer;
          const isCurrent = conn === connection;
          if (isCurrent) {
            conn = null;
            setStatus(`Connection to ${peerId} closed.`);
            updateSendButtonState();
            incomingMeta = null;
          }
          console.log(`%câŒ Connection Closed: ${peerId}`, 'color: #ef4444; font-weight: bold;');
        });

        conn.on('error', (err) => {
          console.error('%cðŸš¨ Connection Error', 'color: #ef4444; font-weight: bold;', err);
          setStatus(`Connection error: ${err.message}`);
          if (conn === connection) {
            updateSendButtonState();
          }
        });
      };

      const initialisePeer = () => {
        const options = {
          host: '0.peerjs.com',
          port: 443,
          path: '/',
          secure: true,
          key: 'peerjs',
          debug: 3, // Maximum debug level for PeerJS
        };

        console.group('%câš™ï¸ Initialising PeerJS', 'color: #8b5cf6; font-weight: bold;');
        console.log('Options:', options);
        console.groupEnd();

        peer = new window.Peer(undefined, options);

        peer.on('open', (id) => {
          localIdEl.textContent = id;
          localIdEl.title = 'Share this ID with the remote peer';
          copyIdBtn.disabled = false;
          connectBtn.disabled = false;
          setStatus('Share your Peer ID with a partner, then connect either way.');
          console.log(`%câœ… Peer Open - ID: ${id}`, 'color: #10b981; font-weight: bold;');
        });

        peer.on('error', (err) => {
          console.error('%cðŸš¨ Peer Error', 'color: #ef4444; font-weight: bold;', err);
          console.log('Error type:', err.type);
          console.log('Error message:', err.message);
          setStatus(`Peer error: ${err.type ?? err.message}`);
        });

        peer.on('connection', (incomingConn) => {
          setStatus(`Incoming connection from ${incomingConn.peer}`);
          console.log(`%cðŸ“ž Incoming Connection from ${incomingConn.peer}`, 'color: #f59e0b; font-weight: bold;');
          wireConnection(incomingConn, 'incoming');
        });

        peer.on('disconnected', () => {
          console.warn('%câš ï¸ Peer Disconnected', 'color: #f59e0b; font-weight: bold;');
        });

        peer.on('close', () => {
          console.log('%câŒ Peer Closed', 'color: #ef4444; font-weight: bold;');
        });
      };

      connectBtn.addEventListener('click', () => {
        const remoteId = remoteIdEl.value.trim();
        if (!remoteId) {
          setStatus('Enter a remote peer ID first.');
          return;
        }

        if (!peer || peer.disconnected) {
          setStatus('PeerJS still initialising. Please wait.');
          return;
        }

        try {
          setStatus(`Connecting to ${remoteId}â€¦`);
          console.log(`%cðŸ“ž Initiating Connection to ${remoteId}`, 'color: #3b82f6; font-weight: bold;');
          const outgoing = peer.connect(remoteId, { reliable: true });
          wireConnection(outgoing, 'outgoing');
        } catch (err) {
          console.error('%cðŸš¨ Peer Connect Error', 'color: #ef4444; font-weight: bold;', err);
          setStatus(`Connection failed: ${err?.message ?? err}`);
        }
      });

      copyIdBtn.addEventListener('click', async () => {
        const id = localIdEl.textContent.trim();
        if (!id || copyIdBtn.disabled) {
          setStatus('Peer ID unavailable to copy yet.');
          return;
        }

        try {
          await navigator.clipboard.writeText(id);
          setStatus('Peer ID copied to clipboard.');
        } catch (err) {
          console.warn('Clipboard API failed, falling back:', err);
          const textarea = document.createElement('textarea');
          textarea.value = id;
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
            setStatus('Peer ID copied to clipboard.');
          } catch (fallbackErr) {
            console.error('execCommand copy failed:', fallbackErr);
            setStatus('Copy failed. Manually select the Peer ID.');
          } finally {
            document.body.removeChild(textarea);
          }
        }
      });

      const transmitFile = async ({ blob, name, mime, hashHex, colorHex }) => {
        if (!isConnected()) {
          throw new Error('Connect to a peer before sending files.');
        }

        const meta = {
          kind: 'file-meta',
          name,
          mime,
          size: blob.size,
        };

        if (hashHex) {
          meta.hashHex = hashHex;
        }

        if (colorHex) {
          meta.colorHex = colorHex;
        }

        console.log('%cðŸ“¤ Sending File Metadata', 'color: #8b5cf6; font-weight: bold;', meta);
        conn.send(meta);
        const arrayBuffer = await blob.arrayBuffer();
        console.log('%cðŸ“¤ Sending File Data', 'color: #3b82f6; font-weight: bold;', `${Math.round(blob.size / 1024)} KB`);
        conn.send(arrayBuffer);
      };

      sendBtn.addEventListener('click', async () => {
        if (!isConnected()) {
          setStatus('Connect to a peer before sending files.');
          return;
        }

        const selectedSource = getSelectedSource();

        if (selectedSource === 'demo') {
          if (!latestDemo) {
            setStatus('Demo PNG not ready. Regenerate it first.');
            updateSendButtonState();
            return;
          }

          try {
            sendBtn.disabled = true;
            setStatus(`Sending ${latestDemo.name} (${Math.round(latestDemo.blob.size / 1024)} KB)â€¦`);
            await transmitFile({
              blob: latestDemo.blob,
              name: latestDemo.name,
              mime: 'image/png',
              hashHex: latestDemo.hashHex,
              colorHex: latestDemo.colorHex,
            });
            setStatus(`Sent ${latestDemo.name} (hash ${latestDemo.hashHex.slice(0, 12)}â€¦).`);
          } catch (err) {
            console.error('Send demo error:', err);
            setStatus(`Failed to send demo PNG: ${err.message ?? err}`);
          } finally {
            updateSendButtonState();
          }

          return;
        }

        const file = fileInput.files?.[0];
        if (!file) {
          setStatus('Choose a file to send.');
          updateSendButtonState();
          return;
          }

          try {
            sendBtn.disabled = true;
            setStatus(`Sending ${file.name} (${Math.round(file.size / 1024)} KB)â€¦`);
            await transmitFile({
              blob: file,
              name: file.name,
              mime: file.type || 'application/octet-stream',
            });
            setStatus(`Sent ${file.name}.`);
          } catch (err) {
            console.error('Send file error:', err);
            setStatus(`Failed to send file: ${err.message ?? err}`);
          } finally {
          updateSendButtonState();
        }
      });

      const revokeDemoUrl = () => {
        if (demoUrl) {
          URL.revokeObjectURL(demoUrl);
          demoUrl = null;
        }
      };

      const createDemoPng = async () => {
        const canvas = document.createElement('canvas');
        canvas.width = 520;
        canvas.height = 280;
        const ctx = canvas.getContext('2d');

        const now = new Date();
        const isoTimestamp = now.toISOString();
        const friendlyTime = isoTimestamp.replace('T', ' ').replace('Z', ' UTC');

        let hashBytes;
        try {
          if (window.crypto?.subtle) {
            const encoder = new TextEncoder();
            const digest = await window.crypto.subtle.digest(
              'SHA-256',
              encoder.encode(`poc4beta-demo::${isoTimestamp}`)
            );
            hashBytes = new Uint8Array(digest);
          }
        } catch (err) {
          console.warn('SHA-256 generation failed, falling back to random bytes.', err);
        }

        if (!hashBytes) {
          hashBytes = new Uint8Array(32);
          if (window.crypto?.getRandomValues) {
            window.crypto.getRandomValues(hashBytes);
          } else {
            for (let i = 0; i < hashBytes.length; i += 1) {
              hashBytes[i] = Math.floor(Math.random() * 256);
            }
          }
        }

        const hashHex = Array.from(hashBytes, toHex).join('').toUpperCase();
        const rgb = [hashBytes[0], hashBytes[1], hashBytes[2]];
        const colorHex = rgbToHex(rgb).toUpperCase();

        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#111827');
        gradient.addColorStop(1, '#1f2937');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.textAlign = 'center';

        const swatchSize = 160;
        const swatchX = (canvas.width - swatchSize) / 2;
        const swatchY = 32;
        ctx.fillStyle = colorHex;
        ctx.fillRect(swatchX, swatchY, swatchSize, swatchSize);
        ctx.lineWidth = 4;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.65)';
        ctx.strokeRect(swatchX, swatchY, swatchSize, swatchSize);

        const textBase = swatchY + swatchSize + 34;

        ctx.fillStyle = '#e5e7eb';
        ctx.font = '20px "Segoe UI", monospace';
        ctx.fillText(colorHex, canvas.width / 2, textBase);

        ctx.fillStyle = '#dbeafe';
        ctx.font = '22px "Segoe UI", sans-serif';
        ctx.fillText(friendlyTime, canvas.width / 2, textBase + 34);

        ctx.fillStyle = '#cbd5f5';
        ctx.font = '16px "Segoe UI", monospace';
        const upperHash = hashHex.toUpperCase();
        const hashLine1 = upperHash.slice(0, 32);
        const hashLine2 = upperHash.slice(32);
        ctx.fillText(hashLine1, canvas.width / 2, textBase + 68);
        ctx.fillText(hashLine2, canvas.width / 2, textBase + 92);

        const blob = await new Promise((resolve, reject) => {
          canvas.toBlob((result) => {
            if (!result) {
              reject(new Error('Unable to generate PNG blob.'));
              return;
            }
            resolve(result);
          }, 'image/png');
        });

        const safeName = `demo-${isoTimestamp.replace(/[:.]/g, '-')}.png`;

        return {
          blob,
          name: safeName,
          hashHex,
          colorHex,
        };
      };

      const applyDemoResult = (result) => {
        latestDemo = result;
        revokeDemoUrl();
        demoUrl = URL.createObjectURL(result.blob);
        demoPreviewImage.src = demoUrl;
        demoPreviewImage.hidden = false;
        demoPreviewImage.alt = `Demo PNG preview with SHA-256 ${result.hashHex}`;
        demoPreviewHash.textContent = `SHA-256 ${result.hashHex.slice(0, 12)}â€¦`;
        demoPreviewHash.title = `Full hash ${result.hashHex}`;
      };

      const prepareDemo = async ({ announce = true, showBusy = true } = {}) => {
        if (showBusy) {
          generateDemoBtn.disabled = true;
          setStatus('Generating demo PNGâ€¦');
        }

        try {
          const result = await createDemoPng();
          applyDemoResult(result);
          if (announce) {
            setStatus(`Demo PNG ready. SHA-256 ${result.hashHex.slice(0, 12)}â€¦.`);
          }
          return result;
        } catch (err) {
          console.error('Demo PNG error:', err);
          setStatus(`Failed to generate demo PNG: ${err.message ?? err}`);
          throw err;
        } finally {
          if (showBusy) {
            generateDemoBtn.disabled = false;
          }
          updateSendButtonState();
        }
      };

      generateDemoBtn.addEventListener('click', () => {
        prepareDemo({ announce: true, showBusy: true }).catch(() => {});
      });

      sourceRadios.forEach((radio) => {
        radio.addEventListener('change', () => {
          if (!radio.checked) {
            return;
          }
          if (radio.value === 'demo') {
            if (latestDemo) {
              setStatus(`Demo PNG selected (hash ${latestDemo.hashHex.slice(0, 12)}â€¦).`);
            } else {
              setStatus('Demo PNG will be ready shortly.');
            }
          } else {
            if (fileInput.files && fileInput.files.length > 0) {
              const file = fileInput.files[0];
              setStatus(`Ready to send ${file.name} (${Math.round(file.size / 1024)} KB).`);
            } else {
              setStatus('Upload a file and press Send.');
            }
          }
          updateSendButtonState();
        });
      });

      fileInput.addEventListener('change', () => {
        if (getSelectedSource() === 'file') {
          if (fileInput.files && fileInput.files.length > 0) {
            const file = fileInput.files[0];
            setStatus(`Ready to send ${file.name} (${Math.round(file.size / 1024)} KB).`);
          } else {
            setStatus('Upload a file and press Send.');
          }
        }
        updateSendButtonState();
      });

      prepareDemo({ announce: false, showBusy: false }).catch((err) => {
        console.error('Initial demo PNG generation failed:', err);
      });

      window.addEventListener('beforeunload', revokeDemoUrl);

      const updatePageFingerprint = async () => {
        if (!window.crypto?.subtle) {
          pageHashEl.textContent = 'Web Crypto unsupported.';
          hashColorEl.textContent = 'X';
          return;
        }

        try {
          const response = await fetch(window.location.href, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const text = await response.text();
          const encoder = new TextEncoder();
          const data = encoder.encode(text);
          const digest = await crypto.subtle.digest('SHA-256', data);
          const hashBytes = new Uint8Array(digest);
          const hashHex = Array.from(hashBytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
          pageHashEl.textContent = hashHex;

          const [r, g, b] = hashBytes;
          hashColorEl.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
          hashColorEl.title = `SHA-256 ${hashHex}`;
          hashColorEl.setAttribute('aria-label', `Page hash colour ${hashHex.slice(0, 6)}`);
        } catch (err) {
          console.error('Fingerprint error:', err);
          pageHashEl.textContent = `Fingerprint unavailable (${err.message}).`;
          hashColorEl.style.backgroundColor = '#9ca3af';
          hashColorEl.title = 'Fingerprint unavailable';
          hashColorEl.setAttribute('aria-label', 'Fingerprint unavailable');
        }
      };

      const ensurePeerReady = () => new Promise((resolve, reject) => {
        if (window.Peer) {
          resolve(window.Peer);
          return;
        }
        const script = document.querySelector('script[data-peerjs]');
        if (!script) {
          reject(new Error('PeerJS script tag missing.'));
          return;
        }
        script.addEventListener('load', () => {
          if (window.Peer) {
            resolve(window.Peer);
          } else {
            reject(new Error('PeerJS loaded but global not found.'));
          }
        }, { once: true });
        script.addEventListener('error', () => reject(new Error('PeerJS failed to load.')), { once: true });
      });

      updatePageFingerprint();
      resetReceivedList();
      updateSendButtonState();

      ensurePeerReady()
        .then(() => {
          initialisePeer();
        })
        .catch((err) => {
          console.error(err);
          setStatus(err.message);
          localIdEl.textContent = 'Unavailable';
          localIdEl.title = err.message;
        });
    </script>
  </body>
</html>
